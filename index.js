// console.log("Hello world");

//!!!!!!!!!!!!!!!!!!MAP

//Метод map() в JavaScript - это встроенная функция массивов, которая создает новый массив путем применения функции обратного вызова к каждому элементу исходного массива. Он применяет заданную функцию к каждому элементу массива и возвращает новый массив, содержащий результаты вызова этой функции для каждого элемента.

// const SomeArr = [1, 2, 3];
// console.log(SomeArr); //1, 2, 3
// const SomeNewArr = SomeArr.map(element => element * 3)

// console.log(SomeNewArr) //3 6 9
// console.log(SomeArr); // 1 2 3

//Оригинальный масссив не изменился

// const SomeArr = [1, 2, 3];
// console.log(SomeArr); //1, 2, 3

// const SomeNewArr = SomeArr.map((element) => {
//     return element * 3;
// });

// console.log(SomeNewArr); //3 6 9
// console.log(SomeArr); // 1 2 3

//каждый массив это объект. Объект - это ссылочный тип. Этот массив имеет свойства, котрые являются индесами определённых элементов в массиве. У каждого свойства есть длина length.

//1. Умножение каждого элемента массива на 2:
//Напишите функцию, которая принимает массив чисел и возвращает новый массив, в котором каждый элемент умножен на 2.

// const arr  = [1, 2, 3];

// const arr1 = arr.map((elem) => elem * 2);

// console.log(arr1);

//2. Преобразование строки в массив строк верхнего регистра: Напишите функцию, которая принимает массив строк и возвращает новый массив, в котором каждая строка преобразована в верхний регистр и разделена на отдельные символы.

// const string = ["abc", "hi", "hello"];

// const string1 = string.map( (STR) => STR.toUpperCase()) //str - это параметр функции, который принимает значение каждого элемента массива при итерации через метод map()

// console.log(string1);

// //2.1. Ещё один пример

// const str = ["1ghbdtn", "привет", 'rfr ltkf&'];

// const str1 = str.map( (st) => st.toUpperCase() );

// console.log(str1);

//3 Извлечение значений из массива объектов: Напишите функцию, которая принимает массив объектов и возвращает новый массив, содержащий значения определенного свойства (например, "name") из каждого объекта.

// const students = [
//     { Call: "1 Fat", years: 30 },
//     { Call: "2 Long", years: 19 },
//     { Call: "3 Jim", years: 29 },
//     { Call: "4 Jim1", years: 28 },
//     { Call: "5 Jim2", years: 89 },
//     { Call: "6 Jim3", years: 99 },
// ];

//console.log(students);

//3.1.1. Удаление объекта!!!

//students.pop(); // удалить объект, который  является последним элементом массива

//3.1.2. Добавление объекта !!!!!

//students.push({Call: "7 James", years: 100});

//console.log(students);

//3.1.3. Добавление и удаление объекта !!!!!

//students.splice(2, 3, {Call: "6 Jim3", years: 99}); //Чтобы удалить 3 элемента из массива с помощью метода splice(), просто передайте вторым аргументом число 3, которое указывает количество элементов, которые нужно удалить, начиная с указанного индекса.

//console.log(students);

//3.1.4. Пример использования filter !!!!!

// const stud = [10, 20, 30 , 40]

// const stud1 = stud.filter( years =>  years > 30);

// console.log(stud1);

//3.1.5. Пример использования indexOf  !!!!!

// const studFiltInd = students.filter(stud => stud.Call.indexOf ('Jim') === -1);

// console.log(studFiltInd);

//Выход в терминал
//[
//     { Call: '1 Fat', years: 30 },
//     { Call: '2 Long', years: 19 },
//     { Call: '3 Jim', years: 29 },
//     { Call: '4 Jim1', years: 28 },
//     { Call: '5 Jim2', years: 89 },
//     { Call: '6 Jim3', years: 99 }
//   ]
//   [ { Call: '1 Fat', years: 30 }, { Call: '2 Long', years: 19 } ]

// 3.1.5. Пример использования includes  !!!!!

// const students = [
//     { Call: "1 Fat", years: 30 },
//     { Call: "2 Long", years: 19 },
//     { Call: "3 Jim", years: 29 },
//     { Call: "4 Jim1", years: 28 },
//     { Call: "5 Jim2", years: 89 },
//     { Call: "6 Jim3", years: 99 },
// ];

// const studFiltInd = students.filter((stud) => stud.Call.includes("Jim"));

// console.log(studFiltInd);

// const arr = [1, 2, 3];

// const arr1 = ["ffff", "ssd", "ss"];

// arr.filter(s => s < 2)

// console.log();

//3.1.6. Пример использования return !!!!!

// const students = [
//     { Call: "1 Fat", years: 30 },
//     { Call: "2 Long", years: 19 },
//     { Call: "3 Jim", years: 29 },
//     { Call: "4 Jim1", years: 28 },
//     { Call: "5 Jim2", years: 89 },
//     { Call: "6 Jim3", years: 99 },
// ];
//   const arr3 = students.map((e)=>{
//     return e.Call

//   })

//   console.log(arr3);

//3.1.7. МОЙ Пример использования return !!!!!

// const stud = [

//     {Name: "1 Nik", age: 21},
//     {Name: "2 Kim", age: 21},
//     {Name: "3 Shrek", age: 21},
//     {Name: "4 Jim", age: 21},

// ];

// const studStorage = stud.map((el) => {
//     return el.Name
// })

// console.log(studStorage);

//4. Преобразование массива строк в массив длин строк: Напишите функцию, которая принимает массив строк и возвращает новый массив, в котором каждый элемент - это длина соответствующей строки из исходного массива.

// 4.1 Муслим

// const stud = [ '1 Fat', '2 Long', '3 Jim', '4 Jim1', '5 Jim2', '6 Jim3' ]

// // console.log(students.map(e=>  e.length));

// 4.1 Мой пример:

// console.log(stud.map((elrment) => elrment.length));// Результат: ["1 Nik", "2 Kim", "3 Shrek", "4 Jim"]

// console.log(stud.length); // пристовыводит длину самого массива - 6

//5. Преобразование массива чисел в массив строк: Напишите функцию, которая принимает массив чисел и возвращает новый массив, в котором каждое число преобразовано в строку.

// const age = [11, 22, 33, 44, 55];

// const res = age.map((el) => {
//    return el.toString()

// });

// console.log(res);

//РЕШЕНИЕ № 2          Приведение типов:

// const num = [2, 4, 6, 8, 10];

// const priv = num.map(elem => '' + elem);

// console.log(priv);

//Конкатенация строки с числом
//Конкатенация строк - это операция объединения двух или более строк в одну строку.
// const t = 111;

// const r =  'о ' + t;
// console.log(r);

// const message = 'The answer is: ' + 42;

// console.log(message);

// const firstName = 'John';
// const lastName = 'Doe';

// const fullName = firstName + ' ' + lastName;

// console.log(fullName);

//РЕШЕНИЕ № 3          Шаблонные строки:

// const num = [11.2, 11.3, 11.4, 11.5,];

// const storage = num.map( elem => `${elem}`)

// console.log(storage);

//ещё

// const r = num.map(e => `${e}`)

// console.log(r);

//6 Извлечение уникальных значений из массива объектов: Напишите функцию, которая принимает массив объектов и возвращает новый массив, содержащий уникальные значения определенного свойства (например, "id") из всех объектов.

// const stud = [
//     { Call: "1 Fat", years: 30, id: 123 },
//     { Call: "1 Fat", years: 30, id: 123 },
//     { Call: "2 Long", years: 19, id: 456 },
//     { Call: "3 Jim", years: 29, id: 789 },
//     { Call: "4 Jim1", years: 28, id: 1011 },
//     { Call: "5 Jim2", years: 89, id: 1213 },
//     { Call: "6 Jim3", years: 99, id: 1415 },
// ];

//console.log(stud.map(el => el.id));

// const id = [...new Set(stud.map((e) => e.id))]; //Этот код создает новый массив, в котором используется метод map() для извлечения всех значений свойства "id" из массива объектов students. Затем создается объект Set, который автоматически удаляет дубликаты. Наконец, с помощью оператора расширения массива ... Set преобразуется обратно в массив уникальных значений "id", который сохраняется в переменной uniqueIds.

//квадратные скобки [...] используются для создания нового массива, который содержит уникальные идентификаторы, преобразованные из массива объектов students с использованием объекта Set.

//new Set(...): Оператор new используется для создания нового экземпляра объекта. В данном случае, мы создаем новый объект Set, который является структурой данных для хранения уникальных значений. При создании нового экземпляра Set, вы передаете массив уникальных идентификаторов, полученный с помощью students.map(el => el.id). Объект Set автоматически удаляет дубликаты, поэтому он содержит только уникальные идентификаторы.

//[...]: Это синтаксис расширения массива (spread syntax), который используется для распаковки элементов из объекта Set в новый массив. Объект Set сам по себе не является массивом, поэтому мы используем расширение массива, чтобы преобразовать его содержимое в массив.

// console.log(id);

//6.1. Пример использования оператора - ... - JavaScript используется для распаковки элементов из итерируемого объекта, такого как массив или объект Set, и создания нового массива или передачи элементов в другую функцию как аргументы.

// const arr = [11, 22, 33];

// const arrTwo = [12, 23, 34];

// const unt = [...arr, ...arrTwo];
// console.log(unt);

//6.1.1 Используем ... - этот оператор для передачи элементов в другую функцию как аргументы

// function plus(x, y, z){
//     return x + y + z;
// }

// const num = [30, 20, 40];

// const res = plus(...num) // Это расширение массива передает каждый элемент массива как отдельный аргумент функции sum

// console.log(res); // Вывод: 90

//6.1.2 Используем Set

//слово Set является зарезервированным словом в JavaScript, используемым для создания структуры данных Set. Set - это объект, который содержит уникальные значения и обеспечивает эффективный способ проверки наличия элемента в коллекции. Он может содержать значения любого типа данных, и каждое значение в коллекции Set появляется только один раз.Set является частью встроенных объектов JavaScript и не может быть использовано в качестве идентификатора для переменных или функций.

// const storage =  new Set();

// storage.add(10);
// storage.add(20);
// storage.add(30);
// storage.add(40);
// storage.add(40);

// console.log(storage);

// console.log(storage.has(20));
// console.log(storage.has(70));

// !!!!!!!!!!!!          ДЕСТРУКТУРИЗАЦИЯ      !!!!!!!!!!!!!!

//  destructured assignment

// Деструктуризация в JavaScript - это специальный синтаксис, который позволяет извлекать значения из массивов или объектов и присваивать их переменным более простым способом. Это удобный способ извлечения данных из структур данных и использования их в коде.

//Деструктуризация объекта

// const user = {
//     Call: "Ike",
//     age: 25,
//     unemployed: true,
// };

// const {  age, Call} = user;
// const { unemployed } = user; //извлекаем значения из объекта и присваиваем их переменным

// console.log(Call);
// console.log(age);
// console.log(unemployed);

//Деструктуризация массива

// const vegetables = ['carrot', 'beet', 'tomato', 'cucumber', 'pickl'];

// const [carrot, beet, tomato, cucumber, picklRick] = vegetables; //порядк элементов важен, НАЗВАНИЯ МОЖНО ДАВАТЬ ЛЮБЫЕ

// console.log(carrot);
// console.log(picklRick);

// //Деструтуризация в функциях

// const user2 = {
//     call: 'Nik',
//     age: 25,
//     employed: true,
// }

// const info = ({call, age, employed}) => { //деструктуризация параметров функции
//     if (!employed){
//         return console.log(`User ${call} has no job`);
//     }
//     return console.log(`User ${call} has a job and him ${age}`);
// }

// info(user2)//User Nik has a job and him 25

//деструкторизацию можно использовать и внутри функции

//Практика!!!

// № 1 Задание
// const user = {
//     call: 'Mik',
//     age:20,
//     country: 'Netherlands'
// }

// const {call, age,   country} = user;

// console.log(call, age, country);

//  № 2 Задание

// const colors = ['red', 'green', 'blue'];

// const [red, green, blue] = colors;

// console.log(red, green, blue);

// № 3 Задание. Деструктуризация в параметрах функции:

// person = {
//     name: "James",
//     age: 25,
// }

// function printPerson({name, age}){
//     return console.log( name, age);
// }

// printPerson(person);

//4. Деструктуризация вложенных объектов:

// const stud = {
//     Sname: 'Alick',
//     about: {
//         evaluations: 5,
//         years: 27,
//     }
// }

// // const {Sname, about} = stud;

// // const {evaluations, years} = about;
// // console.log(Sname, about, evaluations, years);

// const {Sname, about: {evaluations, years}} = stud;  //ПРЕДПОЧТИТЕЛЬНЕЕ!
// console.log(Sname,  evaluations, years);

//5.Использование значения по умолчанию:

// const person = {
//     Sname: 'John',
//     age: 30,
// };

// const {Sname, age, country = 'USA' } = person;

// console.log(Sname, age, country);

// Условные инструкции (Тернарный оператор (выражение которое возвращает результат), switch, if, if ... else)

//Инструкция выполняет определённое действие

/*

Парсинг - это процесс анализа и извлечения структурированных данных из текста или другого вида входной информации. Этот процесс может включать в себя различные этапы, такие как синтаксический анализ, сегментация, токенизация, анализ грамматики и т. д., в зависимости от конкретных требований задачи и формата данных.

Например, парсинг HTML-страницы может включать в себя извлечение информации из тегов HTML, а парсинг JSON-файла - извлечение данных из JSON-структуры.

В общем, цель парсинга состоит в том, чтобы преобразовать неструктурированные или слабоструктурированные данные в структурированный формат, который можно обработать и использовать для различных целей, таких как анализ, хранение, визуализация и др.
*/

// {
//     "userId": 1,
//     "id": 1,
//     "title": "Test title",
//     "status":{
//         "completed": false
//     }
// }
// JSON- формат обмена данными между клиентом и API.

//Передача данных происходи в виде строки:

//{"userId": 1,"id": 1,"title": "Test title","status":{"completed": false}}

//JSON (JavaScript Object Notation) является форматом обмена данными, который широко используется для передачи структурированной информации между клиентскими приложениями и серверными API. JSON представляет собой текстовый формат, основанный на JavaScript, и позволяет представлять данные в виде пар ключ-значение, массивов и вложенных структур данных.

// JSON обычно применяется в веб-разработке для обмена данными между клиентом и сервером посредством HTTP-запросов. Например, когда клиентское веб-приложение отправляет запрос на сервер для получения данных или отправляет данные на сервер для обработки, они могут быть представлены в формате JSON. Затем сервер обрабатывает запрос и отправляет ответ также в формате JSON, который затем может быть обработан клиентским приложением.

// JSON прост в использовании, легко читаем и записываем для человека, а также легко обрабатывается компьютером. Это делает его популярным выбором для обмена данными во многих веб-приложениях и API.

// "" - объязытально нужно использовать двойные кавычки в JSON

// как конвертировать JSON:

//От сервера JSON.parse()  //из строки обратно в объект
//От клиента JSON.stringify() //из объекта  обратно в строку


//То что я вводил в консоль:

/*

const data = {
    title: 'Title', words: 5 
}
undefined
data
{title: 'Title', words: 5}title: "Title"words: 5[[Prototype]]: Objectconstructor: ƒ Object()hasOwnProperty: ƒ hasOwnProperty()isPrototypeOf: ƒ isPrototypeOf()propertyIsEnumerable: ƒ propertyIsEnumerable()toLocaleString: ƒ toLocaleString()toString: ƒ toString()valueOf: ƒ valueOf()__defineGetter__: ƒ __defineGetter__()__defineSetter__: ƒ __defineSetter__()__lookupGetter__: ƒ __lookupGetter__()__lookupSetter__: ƒ __lookupSetter__()__proto__: (…)get __proto__: ƒ __proto__()set __proto__: ƒ __proto__()
JSON
JSON {Symbol(Symbol.toStringTag): 'JSON', parse: ƒ, stringify: ƒ, rawJSON: ƒ, isRawJSON: ƒ}isRawJSON: ƒ isRawJSON()parse: ƒ parse()length: 2name: "parse"arguments: (…)caller: [Исключение: TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
    at Function.invokeGetter (<anonymous>:3:28)][[Prototype]]: ƒ ()[[Scopes]]: Scopes[0]rawJSON: ƒ rawJSON()stringify: ƒ stringify()length: 3name: "stringify"arguments: (…)caller: (…)[[Prototype]]: ƒ ()[[Scopes]]: Scopes[0]Symbol(Symbol.toStringTag): "JSON"[[Prototype]]: Object
JSON.STR
undefined
JSON.stringify(post)
VM255:1 Uncaught ReferenceError: post is not defined
    at <anonymous>:1:16
(анонимная) @ VM255:1
JSON.stringify(data)
'{"title":"Title","words":5}'
JSON
JSON {Symbol(Symbol.toStringTag): 'JSON', parse: ƒ, stringify: ƒ, rawJSON: ƒ, isRawJSON: ƒ}
const pastData = JSON.stringify(data)
undefined
JSON.parse(pastData)
{title: 'Title', words: 5}title: "Title"words: 5[[Prototype]]: Objectconstructor: ƒ Object()hasOwnProperty: ƒ hasOwnProperty()isPrototypeOf: ƒ isPrototypeOf()propertyIsEnumerable: ƒ propertyIsEnumerable()toLocaleString: ƒ toLocaleString()toString: ƒ toString()valueOf: ƒ valueOf()__defineGetter__: ƒ __defineGetter__()__defineSetter__: ƒ __defineSetter__()__lookupGetter__: ƒ __lookupGetter__()__lookupSetter__: ƒ __lookupSetter__()__proto__: (…)get __proto__: ƒ __proto__()set __proto__: ƒ __proto__()

*/






//.then(response => response.json()) // Преобразует тело ответа в объект JavaScript


//задания

//Условные инструкции,  Условная инструкция if else, Использование if в функциях, Инструкция Switch
//Тернарный оператор
//Циклы
//Цикл for
// Для перебора массивов не нужен for
// Цикл while
// Цикл do while
// Цикл for in
// Методы keys и values для объектов
// Цикл for in для массивов
// Цикл for of


//Напишите программу, которая проверяет, является ли число четным или нечетным

// function Even0rOdd(num){
//     if(num % 2 === 0){
//         return "Даноое число - " + num + " - чётное"
//     } else {
//         return "Данное число -" + num + " - НЕ чётное"
//     }
// }


// let num = 17;
// console.log(Even0rOdd(num));
// const a = 10;
// console.log(a % 2);




// const n = 11;

//     ((n) => {
//         if(n %2 === 0){
//             return console.log(n + " число чётное"); 
//         } else{
//             return console.log(n + " число не чётное"); 
//         }
//     })(n)



    /*

((n) => {
    if (n % 2 === 0) {
        console.log(n + " - число чётное");
    } else {
        console.log(n + " - число нечётное");
    }
}) - а зачем писать эту функцию в рамках круглых скобок
ChatGPT
Помещение функции в круглые скобки имеет особое значение в JavaScript. Если вы хотите вызвать стрелочную функцию сразу после ее определения (также известное как "IIFE" - Immediately Invoked Function Expression), вам нужно обернуть определение функции в круглые скобки.

Почему это необходимо? При определении функции JavaScript интерпретатор ожидает, что после определения функции будет следовать тело самой функции. Однако, если вы хотите немедленно вызвать эту функцию, вы должны заключить определение функции в скобки, чтобы интерпретатор понял, что это не только определение функции, но и ее вызов.

Вот пример:

javascript
Copy code
// Объявление и немедленный вызов стрелочной функции
((n) => {
    if (n % 2 === 0) {
        console.log(n + " - число чётное");
    } else {
        console.log(n + " - число нечётное");
    }
})(11); // Передача значения 11 в качестве аргумента для переменной n
Таким образом, ваши круглые скобки не являются частью определения функции, они используются для немедленного вызова этой функции.






    */


// num = 12

// function func (num)  {

//     if(num % 2 === 0){
//         return console.log( `чётное - ${num} - число`);
//     }else{
//         return console.log(`не чётное - ${num} - число`); 
//     }
// }

// func(num)




//самый короткий вариант:
// num = 12

//     if(num % 2 === 0){
//         console.log( `чётное - ${num} `);
//     }else{
//         console.log(`не чётное - ${num} `); 
//     }



//2. Условная инструкция if else: Создайте программу, которая проверяет, является ли число положительным, отрицательным или нулем.

// function Even0rOdd(num){
    
//     if(num != 0 ){ 
//         if(num % 2 === 0){
//         return "Даноое число - " + num + " - чётное"
//         } else {
//         return "Данное число -" + num + " - НЕ чётное"
//         }
//     } else {
//         return console.log("NULL");
//     }
// }


// let num = 1;
// console.log(Even0rOdd(num));






//3. Использование if в функциях: Напишите функцию, которая принимает на вход число и выводит сообщение о том, является ли оно четным или нечетным.




// const read  = require('readline');

// const ObjInterfaceIO = read.createInterface({
//     input: process.stdin,
//     output: process.stdout
// });



//     function func (num) {
//         if(num % 2  === 0) {
//             console.log(num + "- чётное");
//         }else{
//             console.log(num + "- не чётное");
//         }
//     }

// ObjInterfaceIO.question('Введи число: ', (inputedNum) =>{
//         const num = parseInt(inputedNum);

//         if (!isNaN(num)){
//             func(num);
//         }else{
//             console.log('Не правильный ввод.');
//         }
//     ObjInterfaceIO.close(); // Закрываем интерфейс после завершения ввода/вывода
// });



//Пример испотзования остатка
//console.log(к = 11 % 10 );




// 4. Инструкция Switch: Напишите программу, которая на основе введенного дня недели выводит соответствующее сообщение (например, "Понедельник", "Вторник", и т.д.).

// let num = parseInt(prompt("Ведите номер дня недели (от 1 до 7)"))

// switch (num){
//     case 1:
//     console.log("Понедельник");
//     break;

//     case 2:
//     console.log("Вторник");
//     break;
    

//     case 3:
//     console.log("среда ");
//     break;

//     case 4:
//     console.log("четверг");
//     break;
    

//     case 5:
//     console.log("пятница");
//     break;
    

//     case 6:
//     console.log("суббота");
//     break;
    

//     case 7:
//     console.log("воскресенье");   
//     break;

//     default:
//     console.log("Еrror");
// }





// Поскольку prompt() возвращает строку, даже если пользователь вводит число, необходимо использовать parseInt() для преобразования этой строки в число




/*

чем switch case отличается от if else

2 / 2

ChatGPT
switch и case и if и else - это оба конструкции управления потоком в JavaScript, но они имеют различные применения и особенности.

Основные различия между switch и case и if и else:

Условия: if и else проверяют условия на истинность или ложность. switch и case сравнивают выражение со значениями в case.

Гибкость: if и else позволяют проверять различные условия, в то время как switch и case сравнивают только одно выражение с несколькими вариантами значений.

Читаемость: В некоторых сценариях switch и case могут сделать код более читаемым, особенно когда требуется проверить одну переменную на несколько возможных значений. Однако при наличии большого количества условий switch и case могут стать громоздкими и менее читаемыми.

Поведение: В switch и case используется строгая проверка равенства (===). В if и else вы можете использовать различные операторы сравнения, такие как ==, ===, <, >, <=, >=.

Поиск: switch и case могут быть более эффективными в некоторых случаях, особенно когда сравнивается одно и то же значение с несколькими вариантами. Однако это зависит от реализации JavaScript.

В общем, if и else предоставляют большую гибкость, в то время как switch и case могут быть более удобными в определенных ситуациях, особенно когда нужно сравнить одно значение с несколькими вариантами.

*/



//Задача на перевод в строку числа и получения его первого элемента

// const d = 23;

// const numm = d.toString()[0];

// console.log(numm);

// console.log(d.toString()[0]);








//5.Тернарный оператор: Напишите программу, которая проверяет, является ли число положительным или отрицательным, используя тернарный оператор.

// let n = parseInt(prompt("Ввод числа: "));


//уcловный оператор
// if(num > 0 || num < 0){
//     console.log("positeve or/and negative");
//     if(num > 0){
//         console.log("positeve");
//     }else{
//         console.log(" negative");
//     }
// } else{
//     console.log("Not a write input");
// }


// let res = (number > 0) ? "Положительное" 
// : (number < 0) ? "Отрицательное" 
// : "Ноль";

// console.log(res);


// let r = (n > 0) ? "Положительное" : (n < 0) ? "Отрицательное": "null";

// console.log(r);







//6. Циклы:Напишите программу, которая выводит числа от 1 до 10 в консоль.


// for (i = 1; i < 11; i++){
//     console.log(i); 
// }



//7 Цикл for: Используя цикл for, выведите все числа от 1 до 20, которые делятся на 3 без остатка.

// for (i = 1; i < 21; i++){
//     if (i % 3 == 0){
//         console.log(i); 
//     }
    
// }


//2-ое решение

// for(i = 3; i < 21; i +=3){
//     console.log(i);
// }

//8. Для перебора массивов не нужен for: Создайте массив чисел и используйте метод forEach() для вывода каждого элемента массива в консоль.


// const a = [1, 2, 3, 4, 5, 65, 67, 88, 99, 100];

// a.forEach((d) => console.log(d));


//9. Цикл while: Напишите программу, которая выводит все числа от 1 до 10 с использованием цикла while.

// let a = 0;
// while(a < 10){
//     a++
//     console.log(a);
// }


//10)Цикл do while: Создайте программу, которая запрашивает у пользователя число, а затем выводит все числа от этого числа до 0 с использованием цикла do while.

// let answer = parseInt(prompt("Введите число: "));


// let i = answer;

// do{
   
//     console.log(i);
//     i--;
// }while (i >= 0);


// let a = answer;
// do{
//     console.log(a);
//     a--
// }while(a >- 0)



// 11) Цикл for in: Создайте объект с несколькими свойствами и используйте цикл for...in для вывода всех его свойств в консоль.


// SomeObj =  {
//     m: 100,
//     v: 10,
//     weight: 11,
// }

// for(let k in SomeObj){
//     console.log(k + " = " + SomeObj[k]);
// }



//Методы keys и values для объектов: Создайте объект и используйте методы Object.keys() и Object.values() для вывода ключей и значений объекта в консоль.

// SomeObj =  {
//     m: 100,
//     v: 10,
//     weight: 11,
// }


// Object.keys(SomeObj).forEach(key => {
    
//     console.log(key, SomeObj[key])

// });

// Object.values(SomeObj).forEach(value => {
//     console.log(value);
// })




/*

Object.keys(SomeObj).forEach - что тут происходит?

ChatGPT
Вы правильно заметили, что в этой строке используется метод Object.keys(), который принимает объект в качестве аргумента и возвращает массив его собственных перечисляемых свойств (ключей). Затем к полученному массиву применяется метод forEach, который выполняет указанную функцию один раз для каждого элемента в массиве.

Таким образом, выражение Object.keys(SomeObj) создает массив из ключей объекта SomeObj, а forEach используется для перебора этого массива. Каждый ключ передается в функцию обратного вызова (key => {...}), которая выводит ключ и соответствующее значение объекта в консоль.

User
(key => {
    
    console.log(key, SomeObj[key])

}); - почему эта функция называется функцией обратного вызова?
ChatGPT
Функция (key => {...}), переданная в качестве аргумента методу forEach, называется функцией обратного вызова, потому что она вызывается автоматически в определенный момент времени программой или методом, когда выполняются определенные условия.

В данном случае, когда forEach перебирает элементы массива, для каждого элемента вызывается функция обратного вызова. Таким образом, функция обратного вызова "обратно вызывается" методом forEach для каждого элемента массива.

Функции обратного вызова часто используются в JavaScript для выполнения определенных действий после выполнения асинхронных операций, перебора массивов или выполнения других действий, когда программе необходимо выполнить какие-то действия в определенный момент времени.

*/



//13. Цикл for in для массивов: Создайте массив и используйте цикл for...in для вывода индексов массива в консоль.

// const a = [0, 1, 2, 3, 4, 5, 6];

// for(key in a){
//     console.log(key);
// }


//Цикл for of:Создайте массив и используйте цикл for...of для вывода всех его элементов в консоль.

// const a = [0, 1, 2, 3, 4, 5, 6];

// for(key of a){
//     console.log(key);
// }


//FOR OF  - НЕ ДЛЯ ОБЪЕКТОВ!!!


// чем отличается Цикл for of от Цикла for in?
// ChatGPT
// Циклы for...of и for...in в JavaScript предназначены для разных целей и имеют различное поведение:

// Цикл for...of:
// Используется для перебора элементов итерируемых объектов, таких как массивы, строки, Map, Set и другие.
// В каждой итерации в переменную записывается значение элемента, а не его индекс или ключ.
// Не перебирает свойства объекта, которые не являются перечисляемыми.
// Не требует явного указания длины объекта или использования индексов.
// Пример использования for...of для массива:

// javascript
// Copy code
// const arr = [1, 2, 3];
// for (const element of arr) {
//     console.log(element); // Выведет: 1, 2, 3
// }
// Цикл for...in:
// Используется для перебора перечисляемых свойств объекта, включая свойства, унаследованные от прототипа.
// В каждой итерации в переменную записывается имя свойства (ключ), а не его значение.
// Может перебирать не только собственные свойства объекта, но и свойства, унаследованные от прототипа, если они перечисляемые.
// Может не гарантировать порядок перебора свойств, особенно в объектах.
// Пример использования for...in для объекта:

// javascript
// Copy code
// const obj = { a: 1, b: 2, c: 3 };
// for (const key in obj) {
//     console.log(key); // Выведет: a, b, c
//     console.log(obj[key]); // Выведет: 1, 2, 3
// }
// Таким образом, основное отличие между for...of и for...in заключается в том, что первый используется для перебора элементов итерируемых объектов, а второй - для перебора свойств объекта.




// function fm(ar){

//     if(ar.length === 0){
//         return undefined;
//     }

//     let maximal = ar[0];

//     for(let i = 1; i < ar.length; i++){
//         if(ar[i] > maximal){
//             maximal = ar[i];
//         }
        
//     }
//     return maximal;
// }

// let inp = prompt("Число: ")
// let arr = inp.split(",").map(Number);
// let f= fm(arr)

// console.log(f);
 






// function findMax(array){
//     if(array.length === 0){
//         return undefined
//     }

//     let max = array[0];
//     for(let i = 0; i < array.length; i++){
//         if(array[i] > max){
//             max = array[i] 
//         }
//     }
//     return max;
// }


// let input = prompt("Число: ");
// let inputArray = input.split(" ").map(Number);

// let res = findMax(inputArray);

// console.log(res);





//  !!!!!!!!!!!!!!!!!!!!!Модули!!!!!!!!!!!!!!

//Модули позволяют струтурировать код по папкам. А также модульность в js позволяют не повторять одни и те же части кода 

//export ... и import ... - появились в ES6



//часть посвященная :
//07:57:21  Модули
// 08:05:07 Создание и запуск модулей с помощью Node
// 08:18:33 Несколько экспортов
// 08:23:11 Правила работы с модулями
// 08:26:18 Практика по созданию нескольких экспортов
// 08:30:30 Как используются модули в React

//-находится в папке modules



/*
User
а разве компиляция программы не означает её выполнение?

ChatGPT
Компиляция программы и её выполнение - это два различных этапа в жизненном цикле программного кода. Давайте разберем их:

Компиляция программы:

Компиляция - это процесс преобразования исходного кода программы из одного языка программирования в другой. Обычно это происходит с высокоуровневых языков программирования в машинный код, который может быть понятен и исполнен процессором компьютера.
Компиляция обычно происходит до выполнения программы и может включать в себя различные этапы, такие как анализ, оптимизация и генерация исполняемого кода.
Результатом успешной компиляции является исполняемый файл или другая форма скомпилированного кода, который может быть запущен и выполнен на компьютере или другом устройстве.
Выполнение программы:

Выполнение - это процесс фактического запуска программы и выполнения её инструкций компьютером в соответствии с заданным алгоритмом.
После успешной компиляции программы, её исполняемый код может быть запущен на целевой платформе для выполнения.
Во время выполнения программы происходит загрузка данных, обработка операций, взаимодействие с внешними ресурсами (например, файлами, сетью) и вывод результатов.
Таким образом, компиляция и выполнение программы - это два различных этапа. Компиляция преобразует исходный код в исполняемый формат, в то время как выполнение означает реальное выполнение программы на компьютере или устройстве.
*/






























//  !!!!!!!!!!!!!!!!!!!!!!!   КЛАССЫ    !!!!!!!!!!!!!!!!!!!!!!!!!!!!



//классы позволяют создавать прототипы для объектов
//на основании прототипов создаются экземпляры
//экземпляры могут иметь свои свойства и методы
//экзнимпляры наследуют свойства и методы прототипов





//создавать классы в js можно и  без команды class

//Классы: Введены в ECMAScript 2015 (ES6) и представляют собой синтаксический сахар для работы с прототипами и создания объектно-ориентированной иерархии. Они используют ключевое слово class для определения класса, а методы определяются внутри тела класса.



//В JavaScript "пропсы" (props) в объектах обычно означают свойства объекта. 

/*
Объекты в JavaScript представляют собой сборники пар "ключ-значение", где каждый ключ является именем свойства, а значение - соответствующим значением этого свойства. Пример объекта с "пропсами":

javascript
Copy code
const person = {
  name: 'John',
  age: 30,
  gender: 'male'
};

console.log(person.name); // Выведет: John
console.log(person.age); // Выведет: 30
console.log(person.gender); // Выведет: male
В этом примере name, age, и gender - это "пропсы" объекта person. Они используются для хранения и доступа к информации о человеке (в данном случае).
*/



/*

получается что все свойства классов  ( как элементов в js) могут быть присчущи и объектам js?

2 / 2

ChatGPT
Да, в JavaScript все свойства и методы, которые могут быть определены в классах (функциях-конструкторах или объектах), также могут быть присущи обычным объектам JavaScript. Это связано с тем, что в JavaScript всё является объектами, включая функции, массивы и даже классы, созданные с помощью ключевого слова class.

Вот некоторые основные типы свойств и методов, которые могут присутствовать как в классах, так и в обычных объектах:

Свойства:

Простые значения (числа, строки, логические значения и т. д.)
Объекты
Функции
Массивы
Другие объекты
Методы:

Функции
Методы, определенные через свойство объекта
Методы, определенные в прототипе объекта
Поскольку в JavaScript объекты могут содержать любые типы данных и ссылаться на другие объекты, вы можете определять любые свойства и методы в объектах, так же как и в классах. Таким образом, объекты в JavaScript обладают большой гибкостью и могут быть использованы для реализации различных паттернов проектирования и структур данных.

*/





/*
а может ли обычный объект создавать прототипы для других объектов?
ChatGPT
Да, в JavaScript любой объект может быть использован в качестве прототипа для других объектов. Прототипное наследование в JavaScript позволяет объектам наследовать свойства и методы других объектов, что делает его мощным инструментом для организации кода и повторного использования.

// Вот пример создания прототипа с использованием обычного объекта:
// */

// // let PapaObj = {
// //     papaProps: "SomePaValue",
// //     papaMethod: function(){
// //         console.log(this.papaProps);
// //     }
// // };

// // let sonObject = Object.create(PapaObj); //Теперь объект sonObject имеет доступ к свойствам и методам объекта PapaObj, так как он был создан с использованием Object.create(PapaObj).

// // sonObject.sonProp = 'valueSon';
// // sonObject.sonMethod = function(){
// //     console.log(this.sonProp);
// // } 


// // sonObject.papaMethod();
// // sonObject.sonMethod();


// //В этом примере sonObject создан с использованием Object.create(PapaObj), что делает PapaObj прототипом для sonObject. Таким образом, sonObject наследует свойства и методы от PapaObj, но также имеет свои собственные уникальные свойства и методы.


//Object.create() - это стандартный метод в JavaScript, который создает новый объект с указанным прототипом и свойствами. Этот метод принимает один аргумент - объект, который станет прототипом для создаваемого объекта.




/*


let PapaObj = {
    papaProps: "SomePaValue",
    papaMethod: fun(){
        console.log(papaProps);
    }
}; - почему нельзя писать методы таким образом?

ChatGPT
Ваш код имеет несколько синтаксических ошибок:

Вам следует использовать ключевое слово function для объявления функции, а не fun().
Вы забыли указать, что papaProps должен быть взят из PapaObj. Для обращения к свойству объекта из его метода используйте ключевое слово this.
Исправленный вариант выглядит следующим образом:

javascript
Copy code
let PapaObj = {
    papaProps: "SomePaValue",
    papaMethod: function() {
        console.log(this.papaProps);
    }
};
Теперь метод papaMethod должен правильно работать, обращаясь к свойству papaProps объекта PapaObj.

User
а почему нужно писать function ? можно ли писть через стрелочные функции ?
ChatGPT
В JavaScript существуют два способа определения функций: через ключевое слово function и через стрелочные функции (=>).

Стрелочные функции имеют некоторые различия по сравнению с обычными функциями, в том числе:

Они не имеют собственного this. Вместо этого они заимствуют this из окружающего контекста. Это означает, что внутри стрелочной функции нельзя использовать this, чтобы обратиться к контексту объекта, в котором она была вызвана.

Они не имеют своего собственного arguments.

В контексте вашего вопроса описанные выше особенности стрелочных функций могут вызвать проблемы при использовании их в методах объекта, так как this в стрелочной функции будет ссылаться на внешний контекст, а не на объект, в котором она была определена. В результате метод не сможет получить доступ к свойствам объекта через this.

Вот пример, как использование стрелочной функции может вызвать проблемы в вашем коде:

javascript
Copy code
let PapaObj = {
    papaProps: "SomePaValue",
    // Используем стрелочную функцию
    papaMethod: () => {
        console.log(this.papaProps); // this здесь будет ссылаться на глобальный контекст, а не на PapaObj
    }
};

PapaObj.papaMethod(); // Выведет undefined
Поэтому в случае определения методов объекта, особенно если они будут использовать this, лучше использовать обычные функции, объявленные с помощью ключевого слова function

*/















//Возвращаемся к классам
//КЛАСС - это Надстройка над JS

//Array и Object - это тоже классы. В JavaScript как Array, так и Object являются встроенными классами (или конструкторами) языка. Они используются для создания массивов и объектов соответственно.


//PascalCase  используется в названии классов

//  this - В конструкторе: Внутри конструктора this ссылается на создаваемый объект, то есть на экземпляр класса, который будет создан при вызове конструктора с помощью оператора new.

// //this указывает на экземпляр класса
// //Пример класса:

// class Comment {
//     constructor(SomeText){ //метод
//         this.SomeText = SomeText //присваивание
//         this.words = 8  //присваивание
//     } //конструктор вызывается только тогда когда вы создаёте новый экземпляр конкретного объекта

//     upvote(){
//         this.words += 1 //вы можете обращаться к свойствам и методам конкретного экземпляра и изменять их значения // upvote - данный метод находится на уровне класса он не будет присвоен как отдельный метод конкретного экземпляра этого коментария но он будет наследоваться всеми экземплярами этого класса коментария (точно также как и forEach или map)
//     }
    
// } // - такой класс (Comment) является всего лищь шаблоном для создания новых объектов и когда мы будем создавать новый экземпляр такого класса, то this будет автоматически ссылаться на такой вот новый экземпляр и ссылаясь на конкретный экземпляр класса вы можете соответсвенно внутри класса, внутри методов класса и свойств класса менять собственные свойства и методы конкретного экземпляра.

/*

Этот комментарий, который вы привели, объясняет использование ключевого слова this в контексте объектно-ориентированного программирования на языке JavaScript. Давайте разберём по частям:

"this указывает на экземпляр класса": this в JavaScript используется для ссылки на текущий объект, к которому применяется контекст. В данном случае, когда вы создаёте экземпляр класса Comment, this будет ссылаться на этот экземпляр.

"то есть такой класс является всего лишь шаблоном для создания новых объектов": Это верно. Класс Comment является шаблоном, описывающим структуру и поведение объектов, которые будут создаваться на его основе.

"когда мы будем создавать новый экземпляр такого класса, то this будет автоматически ссылаться на такой вот новый экземпляр": Когда вы создаёте новый объект на основе класса Comment, например, let comment = new Comment('some text');, внутри конструктора и методов this будет ссылаться на этот конкретный экземпляр comment.

"ссылаясь на конкретный экземпляр класса вы можете соответственно внутри класса, внутри методов класса и свойств класса менять собственные свойства и методы конкретного экземпляра": Правильно. Используя this в методах класса, вы можете обращаться к свойствам и методам конкретного экземпляра и изменять их значения. Например, в методе upvote() класса Comment, this.words += 1; увеличивает количество слов в конкретном комментарии на 1.




User
"когда мы будем создавать новый экземпляр такого класса, то this будет автоматически ссылаться на такой вот новый экземпляр"  - объясни это выражение по подробнее и по понятнее
ChatGPT
Конечно, давайте разберём это более подробно.

Когда вы создаёте новый объект на основе класса в JavaScript, это создаёт экземпляр этого класса. Другими словами, это конкретный объект, который содержит все свойства и методы, определённые в этом классе.

Когда вы внутри этого класса обращаетесь к ключевому слову this, оно ссылается именно на этот экземпляр класса, на тот объект, который вы создали с помощью этого класса.

Таким образом, если вы используете this внутри метода класса, этот this будет автоматически указывать на текущий экземпляр класса, к которому применяется этот метод.

Например, если у вас есть класс Comment, и вы создаёте новый комментарий с помощью этого класса, когда вы обращаетесь к this внутри метода этого класса, он будет автоматически ссылаться на созданный вами конкретный комментарий. Таким образом, вы можете легко изменять свойства этого конкретного комментария с помощью this.
*/






//экземпляры классов в js создаются с помощью вызова функций!!!

//ЧТО ОЗНАЧАЕТ ВЫРАЖЕНИЕ  - ЧТО "экземпляры классов в js создаются с помощью вызова функций"?

// Высказывание "экземпляры классов в JavaScript создаются с помощью вызова функций" может быть немного запутанным, но имеет смысл, когда говорим о создании объектов на основе классов в JavaScript.

// В JavaScript классы, определенные с использованием ключевого слова class, фактически являются функциями-конструкторами. При создании экземпляра класса с использованием оператора new, вызывается функция-конструктор класса для создания нового объекта.

//Пример:


// class Man {
//     constructor(call){
//         this.call = call;
//     }
// }


// let Alex = new Man("Johny");

// console.log(Alex instanceof Man);
//Оператор instanceof в JavaScript используется для проверки, принадлежит ли объект к определенному классу или наследует ли его от определенного класса.

// Здесь Person - это функция-конструктор, определенная с использованием ключевого слова class. При использовании оператора new эта функция вызывается, чтобы создать новый объект john, который является экземпляром класса Person.

// Таким образом, в контексте JavaScript можно сказать, что экземпляры классов создаются с помощью вызова функций, имея в виду, что классы на самом деле являются функциями-конструкторами, которые вызываются при создании объектов с использованием оператора new.



/*
что такое экземпляр класса?
ChatGPT
Экземпляр класса - это конкретный объект, который был создан с использованием определения класса. Когда вы создаете экземпляр класса, вы создаете конкретный объект, который имеет свойства и методы, определенные в этом классе.

Другими словами, экземпляр класса представляет собой конкретное воплощение (инстанцию) класса. Класс сам по себе является шаблоном или описанием, а экземпляры класса - это конкретные объекты, которые соответствуют этому описанию.

Пример:

javascript
Copy code
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
  }
}

// Создание экземпляра класса Person
let john = new Person("John", 30);

// Создание еще одного экземпляра класса Person
let mary = new Person("Mary", 25);

john.greet(); // Выведет: Hello, my name is John and I am 30 years old.
mary.greet(); // Выведет: Hello, my name is Mary and I am 25 years old.
Здесь john и mary - это экземпляры класса Person, каждый из которых является отдельным объектом со своими собственными значениями свойств name и age.

User
 greet() - что это ? Спец функция?
ChatGPT
Функция greet() в приведенном примере является методом класса Person. В контексте классов в JavaScript, метод - это функция, определенная внутри тела класса. Он представляет собой действие или операцию, которую можно выполнить с экземпляром класса.

В данном примере метод greet() отвечает за приветствие объекта класса Person, выводя его имя и возраст в консоль.

Методы класса работают так же, как обычные функции, но они связаны с объектами класса и могут получать доступ к их свойствам через ключевое слово this.

Пример использования метода:

javascript
Copy code
let john = new Person("John", 30);
john.greet(); // Вызов метода greet() для объекта john
Этот вызов метода greet() приведет к выводу приветствия в консоль, используя имя и возраст объекта john.

User
как соотносятся между собой понятие экземпляр и прототип?
ChatGPT
Понятие экземпляра и прототипа тесно связаны в JavaScript, поскольку прототип используется для реализации наследования и доступа к свойствам и методам объекта.

Экземпляр (инстанс): Экземпляр класса - это конкретный объект, созданный на основе определения класса. Каждый экземпляр имеет свои собственные значения свойств и методов, определенных в классе.

Прототип: Прототип - это объект, который является общим для всех экземпляров класса и содержит свойства и методы, которые могут быть унаследованы всеми экземплярами этого класса. Каждый объект в JavaScript имеет ссылку на свой прототип, через который он может наследовать свойства и методы.

Соотношение между экземпляром и прототипом заключается в том, что каждый экземпляр класса имеет свой прототип. Когда вы обращаетесь к свойству или методу объекта, JavaScript сначала ищет его в самом объекте. Если свойство или метод не найдены непосредственно в объекте, JavaScript будет искать их в прототипе этого объекта. Если они не найдены и в прототипе, поиск будет продолжен в прототипе прототипа и так далее, пока не будет найдено соответствующее свойство или метод или пока не будет достигнут конечный прототип null.

Это механизм, который обеспечивает наследование в JavaScript и позволяет объектам иметь доступ к общим свойствам и методам, определенным в прототипе своего класса.
*/


//СОЗДАНИЕ ЭКЗЕМПЛЯРА КЛАССА:
//с помощью ключевого слова new которое используется для создания новых экземпляров объектов с использованием конструктора. Например, new Object() создаст новый объект, а new Date() создаст новый объект типа Date.

//здесь создаётся экземпляр firstText класса - Comment
// const firstText = new Comment("First comment"); //в new Comment - происходит вызов функции constructor, который создаёт новый экземпляр объекта  класса Comment

// console.log(firstText); 


// /*
// Comment {SomeText: 'First comment', words: 8}
// SomeText : "First comment"
// words :  8
// 🔽 [[Prototype]]:  Object
//     ▶️ constructor : class Comment
//     ▶️ upvote : ƒ upvote()
//     ▶️ [[Prototype]] : Object
// */

// //Классы наследуют по умолчанию также методы объектов


// //цепочка прототипов :
// //firstComment => Comment => Object

// console.log( firstText instanceof Comment); //true
// console.log(firstText instanceof Object);  // true


// //вызов унаследованных методов:

// firstText.upvote()
// console.log(firstText.words); //9

// firstText.upvote()
// console.log(firstText.words); //10


//здесь мы вызываем метод upvote() - как метод объекта firstText


/*

что делает метод object.assign?
ChatGPT
Метод Object.assign() в JavaScript используется для копирования значений всех перечисляемых свойств из одного или нескольких исходных объектов в целевой объект. Возвращает целевой объект после присваивания свойств. Если несколько объектов содержат одинаковые ключи, то значения из последних объектов перезапишут значения из предыдущих объектов. Вот пример его использования:

javascript
Copy code
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

Object.assign(target, source);

console.log(target); // { a: 1, b: 4, c: 5 }
Здесь target изменяется так, чтобы содержать все свойства из source. Если свойство уже существует в target, оно будет перезаписано значением из source.


*/



//Практика по созданию классов и экземпляров

//Вод в консоль


// class Text { 
//     constructor(word) {  //прототипы
//             this.SomeWord = word   
//             this.wordsQuolity = 0 
//         }
    
//     upvote() {  //прототипы
//         this.wordsQuolity += 1
//     }
// }



// Text.prototype.constructor  === Text
    
// true // --Это происходит потому, что свойство constructor прототипа Text указывает на сам класс Text.

//





// firstText
// Text {SomeWord: 'First text', wordsQuolity: 0}
// SomeWord :  "First text"
// wordsQuolity :  0 
// [[Prototype]]
// : 
// Object






/*


const firstText = new Text('First text')
undefined
firstText
Text {SomeWord: 'First text', wordsQuolity: 0}SomeWord: "First text"wordsQuolity: 0[[Prototype]]: Objectconstructor: class Textupvote: ƒ upvote()[[Prototype]]: Objectconstructor: ƒ Object()hasOwnProperty: ƒ hasOwnProperty()isPrototypeOf: ƒ isPrototypeOf()propertyIsEnumerable: ƒ propertyIsEnumerable()toLocaleString: ƒ toLocaleString()toString: ƒ toString()valueOf: ƒ valueOf()__defineGetter__: ƒ __defineGetter__()__defineSetter__: ƒ __defineSetter__()__lookupGetter__: ƒ __lookupGetter__()__lookupSetter__: ƒ __lookupSetter__()__proto__: (…)get __proto__: ƒ __proto__()set __proto__: ƒ __proto__()
firstText.upvote
ƒ upvote() {  //прототипы
        this.wordsQuolity += 1
    }
firstText.SomeWord
'First text'
firstText.wordsQuolity
0
firstText.upvote()
undefined
firstText
Text {SomeWord: 'First text', wordsQuolity: 1}SomeWord: "First text"wordsQuolity: 1[[Prototype]]: Object
firstText.upvote()
undefined
firstText.wordsQuolity
2
firstText.hasOwnProperty('SomeWord')
true
firstText.hasOwnProperty('upvote')
false
firstText.hasOwnProperty('hasOwnProperty')
false

*/



// const firstText = new Text('First text')
// const SecondText = new Text("Second text")
// const ThirdText = new Text("Thrid text")







// Статические методы:

// class Text { 
//     constructor(word) {  //прототипы
//             this.SomeWord = word   
//             this.wordsQuolity = 0 
//         }
    
//     upvote() {  //прототипы
//         this.wordsQuolity += 1
//     }

//     static mergeWords(One, Two){ //статический метод
//         return `${One} ${Two}`
//     }
// }
 

//static mergeWords(One, Two) -  метод доступен как свойство класса и не наследуется экземплярами класса !!!, создаются на уровне методов класса 

//static  - ключевое слово 

//Конструктор вызывается автоматически при создании нового экземпляра класса с помощью оператора new. Обычные методы вызываются явно через экземпляр класса. !!!!!! (это относится и к статическим методам)

// Text.mergeWords('One word.', 'Two word.');               

//Text.mergeWords('Some text', 'Some One Text') - в консоле данный метод вызывается через название класса (тоесть как метод объекта Text не как метод экземпляра объекта - в этом и есть отличие статических методов и унаследованных методов) !!!!

// метод upvote() - наследуется другим экземплярам а статический метод не наследуется !!!!






// Расширение других классов - т.е. мы расширяем класс Array и хотим добавить ещё один метод, который будет доступен всем массивам (экземплярам), которые создаются используя класс NumArr. 

//Здесь клас NumArr расширяет класс Array 
//Задача данного примера: для любого массива, для любого массива, который создаётся добавлять также метод sum, который (родительский конструктор  Array - вызовется автоматически ) автоматически будет суммировать все элементы массива



//constructor не нужен. (родительский конструктор  Array - вызовется автоматически )


//когда создаётся экземпляр класса myArr, то сначала вызывается конструктор родительского класса Array, который возвращает новый объект (новый массив и это будет массив, которому будут доступны все методы такие как forEach, map, reduce и т.д. ) и благодаря этому у нас будет создан объект, который будет выглядить как массив. Он будет сначала наследовать методы NumArr - а он в свою очередь все методы Array - а он в свою очередь будет наследовать все методы объекта





/*

NumArr(3) [2, 5, 7]
0 : 2
1 : 5
2 : 7
length :  3
🔽[[Prototype]] : Array
    ▶️constructor : class NumArr
    ▶️sum : sum() { return this.reduce((ac, elem) => {…}
    ▶️[[Prototype]] : Array(0)


*/




/*
myArr.sum() //вызываем метод sum()  в консоле для того что бы суммировать числа
14
*/


//    Цепочка прототипов:

// myArray => NumbersArray  => Array  => Object

// class NumArr extends Array { 

//     sum() {
//         return this.reduce((ac, elem) => ac + elem, 0)
//     }
// }

// const myArr = new NumArr(2, 5, 7)

// console.log(myArr);

// myArr.sum() //суммирование с помощью reduce()

// //конструктор не нужен

// console.log(myArr.sum());


//extends - дополнение

//Можно сказать что мы расширяем массив Array и хотим добавить ещё один метод всем массивам


//return this.reduce((ac, elem) => ac + elem, 0)

// Синтаксис на этой строке определяет определение класса NumArr, который расширяет встроенный класс Array. Вот разбор синтаксиса:

// class NumArr extends Array: Это объявление класса NumArr, который расширяет встроенный класс Array. Это означает, что класс NumArr наследует все свойства и методы класса Array, такие как push(), pop(), reduce() и т. д. Это позволяет нам создавать массивы, которые также будут иметь доступ к методам, определенным в классе NumArr.

// В методе sum(): reduce((ac, elem) => ac + elem, 0): Этот метод использует метод reduce() для вычисления суммы элементов массива. Метод reduce() принимает функцию обратного вызова и начальное значение. В данном случае, функция обратного вызова принимает два аргумента ac (аккумулятор) и elem (текущий элемент массива) и возвращает их сумму. Начальное значение установлено в 0, что означает, что сумма будет начинаться с нуля.









// !!!!!!!!!!!!!!       Что такое прототип в js?


//У каждого экземпляра того или иного класса есть скрытое свойство -   __proto__     - именно благодаря этому свойству создаётся цепочка прототипов!!!



//если какой-то метод не найден в каком-то объекте то мы смотрим и ищем на уровне родительского прототипа если и там не найден ищем дальше и так по всей цепочке прототипов!!!



//строки и числа - ведут себя как объекты


/*


const num = 10
undefined
num.toString()
'10'


*/



/*
что такое прототип в классах (объясни простыми словами , приведи аналогию ) и как прототип соотносится с классом и с экземпляром класса?
ChatGPT
Прототип в классах JavaScript - это специальный объект, который содержит общие свойства и методы, доступные для всех экземпляров класса. Можно представить прототип как некий шаблон или чертеж, по которому создаются экземпляры класса.

Давайте представим, что класс - это фабрика для производства машин. Прототип будет представлять собой стандартные детали и инструкции по сборке машин, которые используются на этой фабрике. Каждая машина, созданная на этой фабрике, будет иметь те же стандартные детали и будет собрана в соответствии с инструкциями из прототипа.

Соотношение прототипа с классом и экземпляром класса можно проиллюстрировать следующим образом:

Прототип и класс: Прототип связан с классом как своеобразный "заготовленный бланк". Когда вы создаете новый класс, JavaScript автоматически создает для него прототип, который содержит общие свойства и методы, определенные в классе.

Прототип и экземпляр класса: Каждый экземпляр класса имеет доступ к своему прототипу. Это означает, что экземпляр может использовать все свойства и методы, определенные в прототипе своего класса. Если у экземпляра нет своего собственного свойства или метода, JavaScript будет искать их в прототипе и использует их оттуда.

Надеюсь, это поможет вам лучше понять концепцию прототипа в классах JavaScript.

User
constructor - это прототип?
ChatGPT
Нет, constructor не является прототипом. В классах JavaScript, constructor - это специальный метод, который используется для создания и инициализации новых экземпляров класса при вызове оператора new.

Прототип - это объект, который содержит общие свойства и методы, доступные для всех экземпляров класса. Этот объект связан с классом и используется для наследования свойств и методов экземплярами этого класса.

Когда вы создаете новый класс, JavaScript автоматически создает для него прототип, который содержит общие свойства и методы, определенные в классе. constructor - это один из таких методов, который определяет, как создавать новые экземпляры класса.

Таким образом, constructor - это часть класса, которая помогает создавать новые экземпляры, в то время как прототип - это объект, который содержит общие свойства и методы, доступные для всех экземпляров этого класса.
*/








///   !!!Преобразование строки в число 

//1-ый способ  //С помощью оператора + (унарный плюс)

// let df = '21';
// let n = +df;
// console.log(n);



/*

Унарный плюс + в JavaScript имеет два основных применения:

Как оператор сложения: Если перед оператором + стоят числа или строки, то он выполняет сложение. Например, 2 + 2 вернет 4, а '2' + '2' вернет '22'.

Как унарный оператор преобразования в число: Если перед оператором + стоит только один операнд, то он преобразует операнд в число, если это возможно. Если операнд уже является числом, то результат останется числом. Если операнд - строка, содержащая числовое значение, то строка преобразуется в число. Если же строка не содержит числовое значение, результатом будет NaN (Not a Number).

В вашем случае, переменная str содержит строку "42", которая представляет собой числовое значение. Поэтому унарный плюс +str преобразует эту строку в число 42.

Таким образом, вы получаете console.log(num); выводит 42.


User
а почему это происходит? Откуда "растут корни этого явления?
ChatGPT
Исторически, в JavaScript унарный плюс + был предназначен для преобразования строк в числа. Это было сделано для обеспечения удобства и консистентности при работе с данными.

Одним из основных сценариев использования JavaScript является работа с веб-страницами и формами. Когда пользователь вводит данные в форму на веб-странице, значения этих данных обычно передаются как строки. Например, значение из поля ввода текста всегда будет строкой. Поэтому было важно иметь способ легко преобразовывать эти строки в числа для выполнения математических операций.

Унарный плюс + является одним из удобных способов преобразования строк в числа, поскольку он короткий и легко читаемый. Он также консистентен с другими языками программирования, такими как PHP и Python, где унарный плюс также используется для преобразования строк в числа.

Таким образом, преобразование строк в числа с помощью унарного плюса + стало распространенной и широко применяемой практикой в JavaScript.

User
что означает выражение - "консистентности при работе с данными."
ChatGPT
"Консистентность при работе с данными" означает соблюдение единых правил и стандартов при обработке и представлении данных. Это означает, что данные должны быть представлены и обрабатываться в одинаковом формате и структуре, чтобы обеспечить их понимание и согласованность в различных частях системы или программы.

В контексте JavaScript и преобразования строк в числа с помощью унарного плюса +, консистентность означает, что различные операции, связанные с данными, должны вести себя предсказуемо и одинаково в различных ситуациях. Например, когда строка представляет числовое значение, она должна преобразовываться в число, чтобы обеспечить правильное выполнение математических операций. Это помогает программистам и разработчикам создавать более надежные и понятные программы, которые легче поддерживать и развивать.






*/



//2-ой способ: С помощью функции parseInt():

// let a = "100";
// let d = parseInt(a);
// console.log(d);

// // 3-ий: С помощью функции parseFloat()
// let a1 = "100.123";
// let d1 = parseFloat(a1);
// console.log(d1);



// //Повтор: С помощью оператора + (унарный плюс)


// let a2 = "100.123";

// let d2 = +a2;

// console.log(d2);


// //4. С помощью конструктора Number():



// let a3 = "100.123";

// let d3 = Number(a3);

// console.log(d3);
















// !!!!!!!       Практика с reduce():

//Сумма элементов массива: Создайте массив чисел и используйте метод reduce(), чтобы вычислить и вывести сумму всех элементов.

// let a = [1, 2, 3, 4, 5];

// let summa = a.reduce((accum, curentNum) => accum + curentNum, 0);

// //про ноль
// //В функции reduce() второй параметр - это начальное значение аккумулятора. В данном случае, передается 0 как начальное значение для переменной accumulator. Это означает, что сумма будет начинаться с 0 и к ней будут последовательно добавляться значения массива numbers. Если бы не было этого второго параметра, reduce() начал бы суммировать с первого элемента массива numbers.

// console.log(summa);




//Задача из собеседования:

// const obj = [
//     { name: "Sirt", cost: 21},
//     {name: "Jeans", cost: 21},
//     {name: " Cap", cost: 21}
// ]

// let d = obj.reduce((acumulator, countPrice) => acumulator + countPrice.cost, 0);


// console.log(d);



// //ещё раз

// const magazine = [
//     { name: "Sirt", dollars: 21},
//     {name: "Jeans", dollars: 21},
//     {name: " Cap", dollars: 21}
// ]


// let d = magazine.reduce((accum, count) =>  accum + count.dollars,3);


// console.log(d);




//Вот несколько заданий для закрепления методов массивов и изучения метода reduce():

//1. Сумма элементов массива: Создайте массив чисел и используйте метод reduce(), чтобы вычислить и вывести сумму всех элементов.

// let a = [1, 2, 3, 4, 5];

// let r = a.reduce((acum, current) => acum + current, 0);

// console.log(r);

















//2. Нахождение среднего значения: Создайте массив чисел и используйте метод reduce(), чтобы найти и вывести среднее значение всех элементов.

//  let a = [10, 20 , 30 , 40, 50];

//  let r = a.reduce((acum, current) => acum + current, 0) / a.length;

//  console.log(r);

















//3. Подсчет количества определенных элементов: Создайте массив с различными элементами, включая повторяющиеся, и используйте метод reduce(), чтобы подсчитать количество определенных элементов.


// let arr = [1, 1, 2, 2, 4, 5];

// let quantityUE = arr.reduce((acum, currentElem) => {

//     if(currentElem in acum){ // происходит проверка наличия текущего элемента массива (currentElem) в объекте аккумулятора (acum).

//         acum[currentElem]++; //Каждый элемент массива служит ключом в объекте acum, а его значение - количество раз, которое этот элемент встречается в массиве. Путем увеличения значения свойства acum[currentElem] на 1 при каждом обнаружении элемента currentElem мы фактически подсчитываем, сколько раз этот элемент встречается в массиве. //То есть здесь происходит фиксация того сколько раз встречался тот или иной элемент 

//     }else{
//         acum[currentElem] = 1; // В этой строке кода устанавливается начальное значение для свойства объекта acum, если текущий элемент массива встречается впервые.
//     }
//     return acum;


// }, {});//Этот пустой объект используется в качестве начального значения аккумулятора, который мы будем заполнять ключами и значениями в процессе выполнения метода reduce().


// console.log(quantityUE);


// let ar = [1, 2, 3, 4, 5,  54, 3, 4, 4, 5, 8, 9 ];

// let res = ar.reduce((acummulator, countValue) => {
//     if(countValue in  acummulator){
//         acummulator[countValue]++
//     }else {
//         acummulator[countValue] = 1
//     }

//     return acummulator


// }, {});

// console.log(res);









// let ar1 = [1, 2, 3, 4, 5,  54, 3, 4, 4, 5, 8, 9 ];


// let r = ar1.reduce((ac, curEl) => {

//     if(curEl in ac){
//         ac[curEl]++
//     }else{
//         ac[curEl] = 1
//     }

//     return ac;


// }, {});



// console.log(r);







//4. Объединение значений в строку: Создайте массив строк и используйте метод reduce(), чтобы объединить все строки в одну строку, разделенную запятыми.

// let ar1 = ["12345",  "54344", "589" ];

// let  res = ar1.reduce((acum, currenEl) => {
  
//         return acum + "," + currenEl;
   


// });


// console.log(res);


//второе решение:


// let ar1 = ["12345",  "54344", "589" ];

// let  res = ar1.reduce((acum, currentEl, currentIndex) => {
//     if (currentIndex === 0) {
//         return currentEl; // Если это первый элемент, вернуть его как начальное значение аккумулятора
//     } else {
//         return acum + "," + currentEl; // Иначе объединить текущий элемент с предыдущими значениями
//     }
// }, '');

// console.log(res);





















/*
if (currentValue in accumulator) {
        accumulator[currentValue]++;
    } else {
        accumulator[currentValue] = 1;
    } - что происходит в данной конструкции объясни пошагово

ChatGPT
Конечно, давайте разберем эту конструкцию пошагово:

if (currentValue in accumulator): Это условие проверяет, есть ли текущее значение currentValue в объекте accumulator в качестве ключа.

Если текущее значение уже есть в объекте accumulator как ключ, это означает, что оно уже встречалось ранее в массиве. В этом случае выполняется следующий блок кода:

javascript
Copy code
accumulator[currentValue]++;
Это увеличивает значение по ключу currentValue в объекте accumulator на 1, что означает, что мы обнаружили еще одно вхождение currentValue.

Если текущее значение не было найдено в объекте accumulator как ключ, это означает, что это первое вхождение этого значения в массив. В этом случае выполняется блок кода в блоке else:

javascript
Copy code
accumulator[currentValue] = 1;
Это устанавливает значение ключа currentValue в объекте accumulator равным 1, так как это первое вхождение этого значения в массив.

Таким образом, в результате работы этой конструкции мы строим объект accumulator, который содержит ключи, соответствующие уникальным значениям в массиве, и значения, представляющие количество их вхождений в массиве.
*/



// //Поиск максимального и минимального значения:Создайте массив чисел и используйте метод reduce(), чтобы найти и вывести максимальное и минимальное значения.

// let ar = [5, 2, 3, 4, 5,  54, 3, 4, 4, 5, 8, 9 ];


// let res = ar.reduce(() => {
//     let min1 = Math.min(...ar);
//     return min1
// })


// let res2 = ar.reduce(() => {
//     let max1 = Math.max(...ar);
//     return  max1
// })

// console.log(res, res2);







// //решение № 2

// let ar2 = [8, 0, 3, 4, 5,  54, 3, 4, 4, 5, 8, 9 ];


// let res22 = ar2.reduce((min1, max1) => {
    
//      min1 = Math.min(...ar); //Math.min - это встроенная функция в JavaScript, которая принимает любое количество числовых аргументов и возвращает наименьшее из них
//      max1 = Math.max(...ar);


//     return min1 + " " + max1
   
// },'')

// console.log("решение № 2", res22);






// //решение № 3


// let ar44 = [8, 0, 3, 4, 5,  54, 3, 4, 4, 5, 8, 9 ];


// let res44 = ar44.reduce((acum, currentEl) => {
    
//     let min =acum[0];
//     let max = acum[1];
    
//         if ( currentEl < min)
//         min = currentEl;
       
//         if (currentEl > max)
//         max = currentEl;
  
//     return [min, max] //res44 - может хранить только одно значение, значение массива в котором хранится два элемента
   
// }, [ar[0], ar[0]]);

// console.log("решение № 3", res44);




// //решение № 3 (ещё раз)


// let storage = ar44.reduce((ac, ce) =>{

//     let min = ac[0];
//     let max = ac[1];

//     if( ce < min){
//         min = ce;
//     }

//     if(ce > max){
//         max = ce
//     }
//     return [min, max]

// }, [ar[0], ar[0]])


// console.log("решение № 3 (ещё раз)", storage);




// //решение № 4 (Bard)

// let SomeStorage = ar44.reduce((acum, curEl) => {

//     let minimal = Math.min(acum[0], curEl); // Guaranteed minimum
//     let maximal = Math.max(acum[1], curEl);  // Guaranteed maximum


//     return [minimal, maximal];

// }, [Infinity, -Infinity]) // Надежное начальное значение

// console.log("решение № 4", SomeStorage[1], SomeStorage[0]);


// // Использует массив для хранения минимального и максимального значений: [minimal, maximal].
// // Начальное значение задается как [Infinity, -Infinity].
// // На каждой итерации reduce() обновляет значения минимального и максимального элементов в массиве.
// // В результате SomeStorage - это массив с двумя элементами: минимальным и максимальным значениями.



// ///Решение № 5 (ПРАВИЛЬНОЕ гугл бард) 

// //более понятное решене так как использует объект для хранения минимального и максимального значений, что делает код более понятным и легкочитаемым.


// const rr = ar44.reduce((accum, currentEl) => { //создаём объект

//     return { //{ ключ: значение }
//         max: Math.max(accum.max, currentEl), 
//         min: Math.min(accum.min, currentEl)
//     };


// }, { min: Infinity, max: -Infinity})

// console.log("Решение № 5", rr.max, rr.min);


// // Использует объект для хранения минимального и максимального значений: { min: minimal, max: maximal }.
// // Начальное значение задается как { min: Infinity, max: -Infinity }.
// // На каждой итерации reduce() обновляет значения минимального и максимального элементов в объекте.
// // В результате rr - это объект с двумя свойствами: min и max, содержащими соответственно минимальное и максимальное значения.




// //Решение №6  (короче 5)



// const value =  ar44.reduce((ac, curEl) => {
//     return [Math.min(ac[0], curEl), Math.max(ac[1], curEl)];
// }, [ar44[0], ar44[0]]);

// console.log("Решение №6 (короче 5)",  value );












// //Решение № 4.1 (Гугл по короче)



// const [i, x] = ar44.reduce(([ii, xx], currVal) => [
    
//     Math.min(ii, currVal), 
//     Math.max(xx, currVal), 

// ], [Infinity, -Infinity]);




// console.log('4.1. Гугл по короче', x, i);





// //Решение № 7 (GPT по короче)


// let SomeRes = ar44.reduce((ac, currentV) => [
    
//     Math.min(ac[0], currentV), 
//     Math.max(ac[1], currentV)

// ], [Infinity, -Infinity]);


// console.log('Решение № 7 (GPT по короче)', SomeRes[1], SomeRes[0]);



//6. Подсчет количества букв в строке: Создайте строку и используйте метод reduce(), чтобы подсчитать количество каждой буквы в строке. Результат должен быть объектом, где ключами являются буквы, а значениями - их количество.

// const str = 'ыsssstring';

// res = str.split('').reduce((acum, curr_value) => {
//     acum[curr_value] = (acum[curr_value] || 0) +1;            
//             return acum;
// }, {});
    
// console.log(res);
// //(acum[curr_value] || 0) - Оно проверяет, существует ли значение acum[curr_value] в аккумуляторе acum


// r = str.split('').reduce((ac, curVal) => {
//     ac[curVal] = (ac[curVal] || 0) +1;
//     return ac;
// }, {});

// console.log(r);




/*

acum[curr_value] = (acum[curr_value] || 0) +1; - объясни подробно что происходит в данной части кода
Объяснение выражения acum[curr_value] = (acum[curr_value] || 0) + 1;
Данное выражение является ключевым для реализации подсчета количества букв в строке с помощью метода reduce().

Разбор по частям:

acum[curr_value]:

acum - это аккумуляторный объект, который используется для хранения количества каждой буквы.
curr_value - это текущий символ, обрабатываемый в цикле reduce().
acum[curr_value] - это значение, соответствующее текущему символу в аккумуляторе.
|| 0:

Оператор || (логическое ИЛИ) используется для проверки, существует ли значение acum[curr_value].
Если acum[curr_value] существует, то его значение используется.
Если acum[curr_value] не существует (т.е. символ встречается впервые), то используется значение 0.
+ 1:

Значение, полученное на предыдущем шаге, увеличивается на 1.
Объединение:

В целом, данное выражение выполняет следующие действия:

Проверяет, встречался ли текущий символ curr_value ранее.
Если символ встречался:
Использует существующее значение acum[curr_value].
Увеличивает это значение на 1.
Если символ не встречался:
Создает новое поле в аккумуляторе acum[curr_value] со значением 1.
Пример:

Итерация 1:

curr_value = "s"
acum["s"] не существует, поэтому используется значение 0 из выражения || 0.
acum["s"] = 0 + 1 = 1
Итерация 2:

curr_value = "t"
acum["t"] не существует, поэтому используется значение 0 из выражения || 0.
acum["t"] = 0 + 1 = 1
Итерация 3:

curr_value = "r"
acum["r"] не существует, поэтому используется значение 0 из выражения || 0.
acum["r"] = 0 + 1 = 1
Итерация 4:

curr_value = "i"
acum["i"] не существует, поэтому используется значение 0 из выражения || 0.
acum["i"] = 0 + 1 = 1
Итерация 5:

curr_value = "n"
acum["n"] не существует, поэтому используется значение 0 из выражения || 0.
acum["n"] = 0 + 1 = 1
Итерация 6:

curr_value = "g"
acum["g"] не существует, поэтому используется значение 0 из выражения || 0.
acum["g"] = 0 + 1 = 1
В результате:

Объект acum будет содержать:
acum["s"] = 1
acum["t"] = 1
acum["r"] = 2
acum["i"] = 2
acum["n"] = 1
acum["g"] = 1
Таким образом, данное выражение является ключевым для реализации подсчета количества букв в строке с помощью метода  reduce().

*/






// //ещё раз

// const a = 'aaaaasdddsdfefdf';

// const d = a.split('').reduce((ac, curr) => {
//     ac[curr] = (ac[curr] || 0) +1;
//     return ac;
// },{})

// console.log(d);



// r = str.split('').reduce((ac, curVal) => {
//     ac[curVal] = (ac[curVal] || 0) +1;
//     return ac;
// }, {});

// console.log(r);

/*
Давайте рассмотрим строку "aabbc". Посмотрим, как будет изменяться объект acum при выполнении каждой итерации reduce():

Первая итерация:

curr_value равно 'a'.
acum[curr_value] равно undefined, поэтому используется второй операнд 0.
Выражение становится 0 + 1, результат 1.
Обновленный объект acum: { 'a': 1 }.
Вторая итерация:

curr_value равно снова 'a'.
acum[curr_value] равно 1.
Выражение становится 1 + 1, результат 2.
Обновленный объект acum: { 'a': 2 }.
Третья итерация:

curr_value равно 'b'.
acum[curr_value] равно undefined, поэтому используется второй операнд 0.
Выражение становится 0 + 1, результат 1.
Обновленный объект acum: { 'a': 2, 'b': 1 }.
Четвертая итерация:

curr_value равно снова 'b'.
acum[curr_value] равно 1.
Выражение становится 1 + 1, результат 2.
Обновленный объект acum: { 'a': 2, 'b': 2 }.
Пятая и последняя итерация:

curr_value равно 'c'.
acum[curr_value] равно undefined, поэтому используется второй операнд 0.
Выражение становится 0 + 1, результат 1.
Обновленный объект acum: { 'a': 2, 'b': 2, 'c': 1 }.
Таким образом, в конечном результате объект acum будет выглядеть так: { 'a': 2, 'b': 2, 'c': 1 }, что соответствует количеству каждой буквы в строке "aabbc".



*/




// !!!!!!!!!!!!!!!  =+ =-

// let r = [2, -4, 5, 10];



// let c1 = 1;

// с =- c1; //этой строкой кода переменной c присваивается новое значение, которое является противоположным значению переменной c1.
// console.log( с, c1);




// // reduce - по видео WebDev

// //https://www.youtube.com/watch?v=AxiqfRchTXQ

// const arr = [1, 2, 3, 4, 5] //15

// let storage = 0 

// for( i = 0; i < arr.length; i++){
//     storage = storage + arr[i];
// }
// console.log('arr: ', storage);



// //меняем название storage на accum и добавляем let

// let  accum1 = 0 
// for( i = 0; i < arr.length; i++){
//     let currentElem = arr[i];
//     accum1 = accum1 + currentElem
// }
// console.log('arr + accum: ', accum1);


// //сокращаем сложение

// let accum2 = 0 

// for( i = 0; i < arr.length; i++){
//     let currentElem = arr[i];
//     accum2 +=  currentElem
// }
// console.log('arr +=: ', accum2);


// //использование reduce()

// let res = arr.reduce((acсum3, currEl) => {
//     acсum3 += currEl;
//     return acсum3 //reduce должен всегда возвращать acсum3
// }, 0); //- здесь мы сократили let accum2 = 0 - т.е. задали начальное значение, Но его можно опустить, если нас устраивает что 1-ый элемент массива в попадёт acum 


// //т.е. начальное значение reduce() может обеспечить сам


// console.log("reduce() + 0", res);





// // сокращаем 


// let res2 = arr.reduce((acсum3, currEl) => {
//     return  acсum3 += currEl;
// }); 

// console.log("сокр", res2);



// // сокращаем //если в стрелочной функции только одна операция то можно опустить фигурные скобки и return

// let res3 = arr.reduce((acсum3, currEl) => acсum3 += currEl); 

// console.log("-{}", res3);






// // # Найти максимальное значение массива

// const ar = [6, 7, 8, 9, 680, 10];


// let maximal  = ar[0];

// for(i = 1; i < ar.length; i++){

//     let curEl = ar[i];

//     if(curEl > maximal)
//     maximal =  curEl;
// }

// console.log("max", maximal);








// // Сокращение



// let acum  = ar[0];

// for(i = 1; i < ar.length; i++){

//     let curEl = ar[i];
    
//     if(curEl > acum )
//     acum  =  curEl;
// }

// console.log("max", acum );




// //редьюс

// res = ar.reduce((accum, currEl) => {

//     if(currEl > accum)
//         accum = currEl;
    
//     return accum;

// });

// console.log('reuduce', res);



// //редьюс сокращение


// res2 = ar.reduce((accum, currEl) => { currEl > accum ? accum = currEl : accum });

// console.log('reuduce сокращение', res);








// // # Находим индекс максимального элемента массива
// const arr = [9, 2, 3, 488, 5, 10, 22, 222]

// let indx = 0;

// for (i = 0; i < arr.length; i++){
//     if(arr[indx] < arr[i])
//     indx = i;
// }


// console.log("indx", indx);



// //заменяем на acum



// let acum = 0;

// for (i = 0; i < arr.length; i++){
//     if(arr[acum] < arr[i])
//     acum = i;
// }


// console.log("acum",  acum);






// // сокращаем




// let acum2 = 0;

// for (i = 0; i < arr.length; i++){
//     let currEl = arr[i]
//     if(arr[acum2] < currEl)  //currEl уже является элементом массива, а не массивом сам по себе. Поэтому писать фигурные скобки не нужно - currEl[i]
//     acum2 = i;
// }


// console.log("acum",  acum2);




// //reduce()

// let acum3 = 0;
// res = arr.reduce((acum3, currEl) => {

//     if(arr[acum3] < currEl)
//     acum3 = i;
// })

// console.log("res",  res); //res undefined




// //добавляем index, array

// let acum4 = 0;
// res2 = arr.reduce((acum4, curEl, index, array) => {

//     if(array[acum4] < curEl)
//     acum4 = index;

//     return acum4
// },0) //в .reduce() по умолчанию если мы ничего не напишем положит в акамулятор нулевой элемент, но так как нам ЭЛЕМЕНТ не нужен (нам нужен индекс по задаче) то мы допишем 0 - начальное значение индекса акамулятора. acum4 = 0 - в первой итерации. Также это делается для того что бы в слечае предачи путого массива не возвращалась ошибка




// console.log("res",  res2)




// // //сокращаем


// // let acum5 = 0;
// // res3 = arr.reduce((acum5, curEl, index, array) => (array[acum5] < curEl) ? index : acum5 ,0)

// // console.log("res",  res3)



// //#4 Посчитать количество отрицательных чисел в массиве

// const arr = [-1, -2, -3, 4, 5, 0, -2 ];

// let sorage = 0;
// for (i = 0; i < arr.length; i++){
//     if(arr[i] < 0) sorage++;
// }

// console.log('Начало', sorage );


// //reduce()

// res = arr.reduce((acum, curEl) => {

//     if(curEl < 0) acum++; //curEl представляет собой значение элемента массива, а не сам массив
    
//     return acum

// },0) //так как мы убрали  let sorage = 0; то нужно дописать в качестве начального значения - },0)

// console.log('reduce()', res);



// //сокращаем

// res2 = arr.reduce((acum, curEl) => (curEl < 0) ? acum + 1 : acum, 0)

// console.log('reduce()', res2);



// //reduce () -  это метод который позволяет применять функцию к массиву
// //acum = 0 (по умолчанию ) 




// превращаем массив в объект:

// const arr = ["Sasha", "Petya", "Иван"];

// let a = arr.reduce((accum, currEl, index) =>{
//     return{
//         ...accum,
//         [index]: currEl,
//     }

// }, {});

// console.log(a);

//1) {} 0 "Sasha" => {0: "Sasha"}

//2){0: "Sasha"} 1 "Petya" => {0: "Sasha", 1:"Petya"}

//3){0: "Sasha"} 1 "Petya" => {0: "Sasha", 1:"Petya", 2:"Иван"}




//7. Создание нового массива на основе текущего: Создайте массив чисел и используйте метод reduce(), чтобы создать новый массив, содержащий квадраты всех чисел из исходного массива.

const arr2 = [1, 2, 3, 4, 5, 6];



// let res = arr2.reduce((acum, curEl) =>{   

//     return [
//     ...acum, //...acum: Расширение аккумулятора acum. Это означает, что все элементы из acum будут скопированы в новый массив.

//     curEl * curEl //curEl * curEl: Квадрат текущего элемента curEl.

//     ]

// }, []) //Указывает начальное значение для аккумулятора acum. Пустой массив [] используется, чтобы начать с пустого аккумулятора.


// console.log("мой метод", res);


//повтор

// let resres = arr2.reduce((ac, currEl) =>  [ ...ac, currEl * currEl],[])
// console.log("resres",resres);




//bard

// const numbers = [1, 2, 3, 4, 5];

// const squaredNumbers = numbers.reduce((acc, curr) => {
//   return acc.concat([curr * curr]); //В данном случае concat() добавляет к acc новый элемент: массив [curr * curr], который содержит квадрат текущего элемента.  [curr * curr]: Это новый массив, который содержит один элемент: квадрат текущего элемента (curr * curr).
// }, []); // без начального значения, первый элемент исходного массива становится начальным значением аккумулятора //Пустой массив [] используется, чтобы начать с пустого аккумулятора //ИНАЧЕ !!- reduce() - начнёт перемножать результат всё тех же пееременных 1 и 2

// console.log("bard", squaredNumbers); // [1, 4, 9, 16, 25]

//.concat() Объединение массивов: concat() соединяет элементы нескольких массивов в один новый массив.Сохранение исходных массивов: Исходные массивы, участвующие в объединении, не изменяются.
//Внутри функции reduce мы используем метод concat для добавления квадрата текущего элемента (curr * curr) к аккумулятору (acc). Метод concat создает новый массив, который является объединением исходного массива (acc) и нового элемента (curr * curr).

//acc - это аккумулятор, который используется функцией reduce. Он представляет собой MACCИВ, который содержит промежуточные результаты вычислений на каждом этапе обхода массива numbers.

//acc.concat([curr * curr]) - это ключевая часть функции reduce, которая позволяет накапливать в аккумуляторе (acc) квадраты элементов из исходного массива numbers.

// //ещё раз для практики повторяем bard

// let res2 = numbers.reduce((ac, currEl) =>{

//     return ac.concat([currEl * currEl]);
// }, [])

// console.log("res2| ещё раз для практики повторяем bard",res2);


// //ещё раз для практики повторяем bard

// const res3 = numbers.reduce((accumul, currElem) => accumul.concat([currElem * currElem]), []) 

// console.log('res3 | ещё раз для практики повторяем bard',res3);






















//ПРИМЕРЫ НЕЖЕЛАТЕЛЬНЫХ РЕЗУЛЬТАТОВ ПРИ НЕ УКАЗАНИИ НАЧАЛЬНОГО ЗНАЧЕНИЯ ДЛЯ reduce()

//Ошибка при попытке выполнить операцию над несовместимыми типами данных:
/*

я правильно понимаю что,  ИНАЧЕ !!- reduce() - начнёт перемножать результат всё тех же переменных 1 и 2 из этого массива и поэтому ему нужно место в виде , []); - что бы хранить там перемноженные результаты массива - const numbers = [1, 2, 3, 4, 5]; ???

2 / 2

ChatGPT
Почти правильно, но немного путаете операцию reduce(). Он не начнет просто перемножать результаты переменных 1 и 2, он будет применять функцию обратного вызова к элементам массива и использовать результаты этих вызовов как новые значения для аккумулятора.

Когда вы используете reduce() без начального значения, он начинает со второго элемента массива и использует первый элемент в качестве начального значения аккумулятора. Это может привести к нежелательным результатам, если первый элемент массива не имеет того типа данных, который ожидается.

Поэтому установка начального значения в виде пустого массива [] обеспечивает, что reduce() начнет с пустого аккумулятора и применит функцию обратного вызова к каждому элементу массива, начиная с первого. Это позволяет корректно создавать новый массив с результатами операций.

User
и к каким нежелательным результатам это может привести?

Save & Submit

Cancel
ChatGPT
Если первый элемент массива не имеет ожидаемого типа данных, то это может привести к ошибкам или непредсказуемому поведению при выполнении операции reduce(). Например, если вы пытаетесь выполнить операцию, ожидающую числовые значения, а первый элемент массива является строкой или другим типом данных, несовместимым с этой операцией, это может вызвать ошибку выполнения или создать непредсказуемый результат.

Вот пример:

javascript
Copy code

*/

//Ошибка при попытке выполнить операцию над несовместимыми типами данных:



// const numbers1 = ["1", 2, 3, 4, 5]; // Первый элемент - строка

// const result = numbers1.reduce((acc, curr) => acc + curr);
// //const result = numbers1.reduce((acc, curr) => acc + Number(curr), 0); - решение проблемы

// console.log("пример",result); // Выведет: "12345"

/*
В этом примере, если первый элемент массива был числом, операция сложения прошла бы успешно. Однако, поскольку первый элемент является строкой, он конкатенируется со всеми остальными элементами массива, а не складывается, что может привести к неожиданному результату.
*/







//ПРИМЕРЫ НЕЖЕЛАТЕЛЬНЫХ РЕЗУЛЬТАТОВ :
//1. Ошибка при попытке выполнить операцию над несовместимыми типами данных:
// const number = [null, "2", 3, 4, 5]; // Первый элемент - null

// const resul = number.reduce((acc, curr) => acc + curr);

// console.log(resul); // Выведет: "null2345"




//2. Непредсказуемый результат при работе с пустым массивом:


// const numbers5 = []; // Первый элемент - null

// const result5 = numbers5.reduce((acc, curr) => acc + curr);

// console.log(result5); // Выведет:  Uncaught TypeError:



// //3. Нежелательный результат при работе с массивом объектов:

// const data = [
//     { value: 1 },
//     { value: 2 },
//     { value: 3 },
//   ];
  
//   const resu = data.reduce((acc, curr) => acc + curr.value); //добавление ",0" - решает проблему
  
// //acc начинается как число 0, а затем к нему добавляется каждое значение curr.value и

//   console.log(resu); // Выведет: [object Object]23


//4.

// const numbers = [true, 2, 3, 4, 5]; // Первый элемент - null

// const result = numbers.reduce((acc, curr) => acc + curr);

// console.log(result); // Выведет: "null2345"








// // //GPT

// const arr = [1, 2, 3, 4, 5, 6];
// // const squares = arr.reduce((acc, cur) => [...acc, cur ** 2], []);

// // console.log("GPT",squares);


// // //выражение cur ** 2 означает возведение текущего элемента массива в квадрат.


// let res = arr.reduce((ac, curEl) => [...ac, curEl**2], []);
// console.log("повтор",res);


// // r = arr.reduce((a, c)=> [...a, c** 2],[]) //Создание копии массива - ...
// // console.log("повтор", r);





// //bard-короткий


// const numbers2 = [1, 2, 3, 4, 5];
// const squared2 = numbers2.reduce((a, c) => a.concat(c * c), []);


// console.log("bard-короткий",squared2); // [1, 4, 9, 16, 25]





// //прошлый вариант
// const res3 = numbers2.reduce((a, c) => a.concat([c * c]), [])


// console.log("прошлый вариант", res3);




// let res2 = numbers2.reduce((ac, currEl) =>{

//         return ac.concat([currEl * currEl]);
//     }, [])
    
//      console.log("res2| ещё раз для практики повторяем bard",res2);


























//!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
// //1. Использование .concat() и оператора ... (spread operator)



// const ar = [1, 2, 3, 4];
// const ar1 = [6, 7, 8, 9]

// const uniteAr = ar.concat(ar1)

// console.log(uniteAr);



// const uniteAr2 =ar.concat(ar1);
// console.log(uniteAr2);








// //2.Передача элементов массива в функцию с помощью оператора ...:


// function un (...arr){
   
//     return arr.reduce((ac, curEl) => ac + curEl);
// }
// console.log(un(2, 5,3));



//3. Копирование массива с помощью оператора ...: Создайте копию существующего массива, используя оператор .... 

// const arr = [100, 101, 102];
// let aa = [...arr]
// console.log(aa)








// const aff = [1, 2, 3, 4, 5]
// const ffa = [...aff]
// console.log(ffa);




//4.Конкатенация массивов с помощью оператора ...:



// let arr = [1, 2, 3, 4]
// let arr1 = [1,2, 3, 4, 5];

// let rr = [...arr, ...arr1]

// console.log(rr);




//5.Параметры функции: Напишите функцию, которая принимает переменное количество аргументов и объединяет их в один массив. Используйте оператор ... для этого.


// function func (...arr){
//     return arr
// }

// console.log(func(1, 2, 3, 4, 5));




//6. Передача аргументов в конструктор объекта: Создайте конструктор объекта, который принимает переменное количество аргументов и инициализирует свойства объекта


//конструктор объекта

// function ConctructBook(page, editions, ...arr){
//     this.page = page;
//     this.editions = editions;

//     this.phrase = function(){
//         console.log(`Изданий - ${this.editions}, страниц - ${this.page}.`);
//     }



//     // Проходим по всем аргументам и инициализируем свойства объекта
//     arr.forEach((arr, index) => { 
//         this[`property${index + 1}`] =arr;
//     })
// }

// const conctructBook = new ConctructBook('Война и мир 1 том', 650)
// console.log(conctructBook.page, conctructBook.editions);

// conctructBook.phrase()



// const conctructBook2 = new ConctructBook(1, 2, 3);
// const conctructBook3 = new ConctructBook(" c", "b", "a")

// console.log(conctructBook2);
// console.log(conctructBook3);



//Отдельный пример
function Book(...arr){
    
    // Проходим по всем аргументам и инициализируем свойства объекта
    arr.forEach((arr, ind) => { 
        this[`Chapter ${ind +1} `] = arr;
    })
}


// Создание экземпляров объекта:
const Book2 = new Book(1, 2, 3);
const Book3 = new Book("c", "b", "a")

console.log (Book2);
console.log(Book3);



/*

this - это ключевое слово, которое внутри функции-конструктора ссылается на создаваемый экземпляр объекта.
В данном контексте this используется для доступа к свойствам этого экземпляра объекта.
2. [property${index + 1}]:

[] - оператор доступа к элементам массива или строкам.
property${index + 1} - строковая переменная, которая формируется динамически.
property - это константа "property".
${index + 1} - шаблонная строка, в которую вставляется значение index + 1.
index - текущий индекс в цикле forEach.
+ 1 - к индексу добавляется 1, чтобы имена свойств начинались с property1 (а не с property0).
В итоге: эта часть кода генерирует динамическое имя свойства.
3. =:

Оператор присваивания.
4. arg:

arg - это переменная, которая содержит текущий элемент массива args (текущий аргумент, переданный конструктору).
Итого:

Вся строка this[property${index + 1}] = arg; означает:

Для каждого аргумента, переданного конструктору:
Создается динамическое имя свойства: property1, property2, property3 и т.д.
Значение текущего аргумента (arg) присваивается этому динамически созданному свойству экземпляра объекта, на который ссылается this.
Пример:

Допустим, вызываем конструктор MyObject с тремя аргументами: 1, 2, 3.
Внутри цикла forEach:
index будет равен 0, 1, 2.
property${index + 1} будет генерировать property1, property2, property3.
arg будет содержать значения 1, 2, 3.
В итоге:
Объекту будут присвоены свойства:
property1 со значением 1.
property2 со значением 2.
property3 со значением 3.
Таким образом, данная строка кода позволяет динамически создавать свойства объекта с уникальными именами, основанными на индексе аргумента, и инициализировать их значениями, переданными конструктору.
*/





//ещё раз 6 задание


// function add(...argument){
//     argument.forEach((argumen, ind) =>{ 

//         this[`Value${ind + 1}`] = argumen

//     })
// }
// let add2 = new add(1, 2, 3)

// console.log(add2);



// //ещё раз 6 задание
// function mansion(...ar){
//     ar.forEach((ar, ind)=>{

//         this[`elem ${ind +1}`] = ar

//     })
// }

// let man1 = new mansion(1, 2, 3)

// console.log(man1);
// console.log(mansion);







//concat



const object1 = {a: 1, b: 2}
const arr = [1, 2, 3,]

let unite = [].concat(object1, arr);

console.log(unite);




/*   

concat и ...  - в чем они отличаются и в какой версии ES их обоих добавили?
ChatGPT
Метод .concat() и оператор ... (spread operator) предоставляют похожий функционал, но есть некоторые отличия.

Метод .concat():
Это метод массива, который используется для объединения двух или более массивов в новый массив.
Пример использования: const newArray = array1.concat(array2);
Добавлен в JavaScript версии 1.2 (ES1) и существует во всех последующих версиях.
Оператор ... (spread operator):
Это оператор, который используется для развертывания элементов итерируемых объектов, таких как массивы или строки, в местах, где ожидается несколько аргументов или элементов массива.
Он также может быть использован для создания копии массива или объединения нескольких массивов.
Примеры использования:
Создание копии массива: const copyArray = [...originalArray];
Объединение массивов: const combinedArray = [...array1, ...array2];
Добавлен в JavaScript в ECMAScript 6 (ES2015) и стал частью стандарта JavaScript с этой версии.
Отличие между ними заключается в их синтаксисе и использовании. .concat() работает как метод массива, тогда как ... - это оператор, который может быть использован для развертывания элементов в различных контекстах, включая объединение массивов и создание копий.

User
получается что .concat() - бесполезен, потому что у оператора расширения - ... - больше функционала, а также у него есть функционал который есть у  .concat(). Разве не так?
ChatGPT
Нет, не совсем так. Оба метода, .concat() и оператор ... (spread operator), имеют свои собственные сценарии использования и могут быть полезны в разных ситуациях.

Вот несколько преимуществ .concat():

Поддержка в старых версиях JavaScript: .concat() доступен во всех версиях JavaScript, включая более старые версии, такие как ES1. Это означает, что он может быть полезен, если вы работаете с кодом, который должен быть совместим с более старыми браузерами или средами выполнения.
Читаемость кода: В некоторых сценариях использование .concat() может сделать код более читаемым, особенно когда вы объединяете большое количество массивов.
Использование с не-массивами: .concat() может принимать не только массивы, но и другие типы данных, такие как строки или объекты, и объединять их вместе. Это расширяет его функциональность за пределы простого объединения массивов.
Однако оператор ... (spread operator) обладает рядом преимуществ:

Краткость и удобство: Оператор ... обычно делает код более кратким и удобным для чтения, особенно когда вы объединяете или копируете массивы.
Использование в различных контекстах: Оператор ... может использоваться не только для объединения массивов, но и для создания копий массивов, передачи аргументов в функции, развертывания объектов и т. д. Это делает его более гибким и мощным инструментом.
Таким образом, хотя оператор ... может заменить .concat() в некоторых сценариях, .concat() все еще имеет свои преимущества и может быть полезен в определенных ситуациях.

User
приведи примеры использования  .concat() с объектами
ChatGPT
Конечно, хотя .concat() обычно используется с массивами, он также может работать с другими типами данных, включая объекты. Однако важно понимать, что .concat() не объединяет объекты так же, как массивы, а склеивает их вместе в новый массив. Вот несколько примеров использования .concat() с объектами:

Соединение объектов в массив:
javascript
Copy code
const obj1 = { a: 1, b: 2 };
const obj2 = { c: 3, d: 4 };

const concatenatedArray = [].concat(obj1, obj2);
console.log(concatenatedArray);
// [{ a: 1, b: 2 }, { c: 3, d: 4 }]
Соединение объектов и массивов:
javascript
Copy code
const obj1 = { a: 1, b: 2 };
const arr1 = [3, 4, 5];

const concatenatedArray = [].concat(obj1, arr1);
console.log(concatenatedArray);
// [{ a: 1, b: 2 }, 3, 4, 5]
Соединение объектов с другими типами данных:
javascript
Copy code
const obj1 = { a: 1, b: 2 };
const str = 'Hello';
const num = 42;

const concatenatedArray = [].concat(obj1, str, num);
console.log(concatenatedArray);
// [{ a: 1, b: 2 }, 'H', 'e', 'l', 'l', 'o', 42]
В этих примерах объекты просто добавляются в массив как отдельные элементы, поэтому результатом является массив, содержащий все переданные объекты и другие значения.






*/



















/*
что такое поверхностное и глубокое копирование в js и может ли оно понадобиться в изучении react js или  может в прохождении собеседований?

ChatGPT
Поверхностное копирование и глубокое копирование - это два подхода к копированию объектов в JavaScript.

Поверхностное копирование (Shallow Copy):
При поверхностном копировании создается новый объект, который содержит те же самые свойства, что и исходный объект, но ссылки на вложенные объекты или массивы остаются теми же самыми. Другими словами, если вы измените вложенный объект или массив в копии, это изменение также отразится на оригинале и наоборот.
Глубокое копирование (Deep Copy):
Глубокое копирование создает полностью независимую копию объекта, включая все вложенные объекты и массивы. Это означает, что изменения в копии объекта не влияют на оригинал, и наоборот.
В React.js и во время собеседований знание глубокого копирования может быть полезным по следующим причинам:

Изменение состояния в React:
В React.js часто используется изменение состояния компонентов. Если вы хотите создать новый объект состояния, основанный на предыдущем, чтобы избежать мутации состояния, вам может потребоваться глубокое копирование.
Работа с данными в React:
При работе с данными, полученными из API или хранилища, иногда требуется создание глубокой копии этих данных для обработки или изменения без влияния на оригинал.
Понимание принципов JavaScript:
Знание различий между поверхностным и глубоким копированием может помочь вам понять, как работает JavaScript и как избежать неожиданных побочных эффектов при работе с объектами и массивами.
Таким образом, понимание и использование глубокого копирования может быть полезным как при изучении React.js, так и при прохождении собеседований, особенно если задачи или вопросы касаются управления состоянием или манипуляции данными.

User
приведи примеры поверхностного копирования и глубокого копирования с наглядными примерами показывающими их различия?
ChatGPT
Конечно, вот примеры поверхностного и глубокого копирования объектов в JavaScript:

Поверхностное копирование (Shallow Copy):

javascript
Copy code
// Исходный объект
const originalObj = {
    a: 1,
    b: {
        c: 2,
        d: 3
    }
};

// Поверхностное копирование
const shallowCopyObj = Object.assign({}, originalObj);

// Изменение свойства в копии
shallowCopyObj.a = 10;

// Изменение вложенного объекта в копии
shallowCopyObj.b.c = 20;

console.log(originalObj); // { a: 1, b: { c: 20, d: 3 } }
console.log(shallowCopyObj); // { a: 10, b: { c: 20, d: 3 } }
Глубокое копирование (Deep Copy):

javascript
Copy code
// Исходный объект
const originalObj = {
    a: 1,
    b: {
        c: 2,
        d: 3
    }
};

// Глубокое копирование с использованием JSON
const deepCopyObj = JSON.parse(JSON.stringify(originalObj));

// Изменение свойства в копии
deepCopyObj.a = 10;

// Изменение вложенного объекта в копии
deepCopyObj.b.c = 20;

console.log(originalObj); // { a: 1, b: { c: 2, d: 3 } }
console.log(deepCopyObj); // { a: 10, b: { c: 20, d: 3 } }
Объяснение:

В случае поверхностного копирования с помощью Object.assign(), создается новый объект, который содержит те же самые свойства, что и исходный объект. Однако, если свойство является объектом или массивом, то в новом объекте будет ссылка на тот же самый объект или массив, что и в исходном объекте. Это означает, что изменения во вложенных объектах будут отражаться как в исходном объекте, так и в его копии.
В случае глубокого копирования с использованием JSON.stringify() и JSON.parse(), объект преобразуется в строку JSON и затем снова преобразуется обратно в объект. Этот процесс создает полностью новый объект, включая все вложенные объекты и массивы. Таким образом, изменения в копии объекта не влияют на исходный объект и наоборот.
Эти примеры иллюстрируют различия между поверхностным и глубоким копированием объектов в JavaScript.
*/



//8.Группировка элементов массива по категориям: Создайте массив объектов, где каждый объект представляет элемент с именем и категорией. Используйте метод reduce(), чтобы сгруппировать элементы по категориям и создать объект, где ключами будут категории, а значениями - массивы элементов из каждой категории.













