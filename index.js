// console.log("Hello world");

//!!!!!!!!!!!!!!!!!!MAP

//Метод map() в JavaScript - это встроенная функция массивов, которая создает новый массив путем применения функции обратного вызова к каждому элементу исходного массива. Он применяет заданную функцию к каждому элементу массива и возвращает новый массив, содержащий результаты вызова этой функции для каждого элемента.

// const SomeArr = [1, 2, 3];
// console.log(SomeArr); //1, 2, 3
// const SomeNewArr = SomeArr.map(element => element * 3)

// console.log(SomeNewArr) //3 6 9
// console.log(SomeArr); // 1 2 3

//Оригинальный масссив не изменился

// const SomeArr = [1, 2, 3];
// console.log(SomeArr); //1, 2, 3

// const SomeNewArr = SomeArr.map((element) => {
//     return element * 3;
// });

// console.log(SomeNewArr); //3 6 9
// console.log(SomeArr); // 1 2 3

//каждый массив это объект. Объект - это ссылочный тип. Этот массив имеет свойства, котрые являются индесами определённых элементов в массиве. У каждого свойства есть длина length.

//1. Умножение каждого элемента массива на 2:
//Напишите функцию, которая принимает массив чисел и возвращает новый массив, в котором каждый элемент умножен на 2.

// const arr  = [1, 2, 3];

// const arr1 = arr.map((elem) => elem * 2);

// console.log(arr1);

//2. Преобразование строки в массив строк верхнего регистра: Напишите функцию, которая принимает массив строк и возвращает новый массив, в котором каждая строка преобразована в верхний регистр и разделена на отдельные символы.

// const string = ["abc", "hi", "hello"];

// const string1 = string.map( (STR) => STR.toUpperCase()) //str - это параметр функции, который принимает значение каждого элемента массива при итерации через метод map()

// console.log(string1);

// //2.1. Ещё один пример

// const str = ["1ghbdtn", "привет", 'rfr ltkf&'];

// const str1 = str.map( (st) => st.toUpperCase() );

// console.log(str1);

//3 Извлечение значений из массива объектов: Напишите функцию, которая принимает массив объектов и возвращает новый массив, содержащий значения определенного свойства (например, "name") из каждого объекта.

// const students = [
//     { Call: "1 Fat", years: 30 },
//     { Call: "2 Long", years: 19 },
//     { Call: "3 Jim", years: 29 },
//     { Call: "4 Jim1", years: 28 },
//     { Call: "5 Jim2", years: 89 },
//     { Call: "6 Jim3", years: 99 },
// ];

//console.log(students);

//3.1.1. Удаление объекта!!!

//students.pop(); // удалить объект, который  является последним элементом массива

//3.1.2. Добавление объекта !!!!!

//students.push({Call: "7 James", years: 100});

//console.log(students);

//3.1.3. Добавление и удаление объекта !!!!!

//students.splice(2, 3, {Call: "6 Jim3", years: 99}); //Чтобы удалить 3 элемента из массива с помощью метода splice(), просто передайте вторым аргументом число 3, которое указывает количество элементов, которые нужно удалить, начиная с указанного индекса.

//console.log(students);

//3.1.4. Пример использования filter !!!!!

// const stud = [10, 20, 30 , 40]

// const stud1 = stud.filter( years =>  years > 30);

// console.log(stud1);

//3.1.5. Пример использования indexOf  !!!!!

// const studFiltInd = students.filter(stud => stud.Call.indexOf ('Jim') === -1);

// console.log(studFiltInd);

//Выход в терминал
//[
//     { Call: '1 Fat', years: 30 },
//     { Call: '2 Long', years: 19 },
//     { Call: '3 Jim', years: 29 },
//     { Call: '4 Jim1', years: 28 },
//     { Call: '5 Jim2', years: 89 },
//     { Call: '6 Jim3', years: 99 }
//   ]
//   [ { Call: '1 Fat', years: 30 }, { Call: '2 Long', years: 19 } ]

// 3.1.5. Пример использования includes  !!!!!

// const students = [
//     { Call: "1 Fat", years: 30 },
//     { Call: "2 Long", years: 19 },
//     { Call: "3 Jim", years: 29 },
//     { Call: "4 Jim1", years: 28 },
//     { Call: "5 Jim2", years: 89 },
//     { Call: "6 Jim3", years: 99 },
// ];

// const studFiltInd = students.filter((stud) => stud.Call.includes("Jim"));

// console.log(studFiltInd);

// const arr = [1, 2, 3];

// const arr1 = ["ffff", "ssd", "ss"];

// arr.filter(s => s < 2)

// console.log();

//3.1.6. Пример использования return !!!!!

// const students = [
//     { Call: "1 Fat", years: 30 },
//     { Call: "2 Long", years: 19 },
//     { Call: "3 Jim", years: 29 },
//     { Call: "4 Jim1", years: 28 },
//     { Call: "5 Jim2", years: 89 },
//     { Call: "6 Jim3", years: 99 },
// ];
//   const arr3 = students.map((e)=>{
//     return e.Call

//   })

//   console.log(arr3);

//3.1.7. МОЙ Пример использования return !!!!!

// const stud = [

//     {Name: "1 Nik", age: 21},
//     {Name: "2 Kim", age: 21},
//     {Name: "3 Shrek", age: 21},
//     {Name: "4 Jim", age: 21},

// ];

// const studStorage = stud.map((el) => {
//     return el.Name
// })

// console.log(studStorage);

//4. Преобразование массива строк в массив длин строк: Напишите функцию, которая принимает массив строк и возвращает новый массив, в котором каждый элемент - это длина соответствующей строки из исходного массива.

// 4.1 Муслим

// const stud = [ '1 Fat', '2 Long', '3 Jim', '4 Jim1', '5 Jim2', '6 Jim3' ]

// // console.log(students.map(e=>  e.length));

// 4.1 Мой пример:

// console.log(stud.map((elrment) => elrment.length));// Результат: ["1 Nik", "2 Kim", "3 Shrek", "4 Jim"]

// console.log(stud.length); // пристовыводит длину самого массива - 6

//5. Преобразование массива чисел в массив строк: Напишите функцию, которая принимает массив чисел и возвращает новый массив, в котором каждое число преобразовано в строку.

// const age = [11, 22, 33, 44, 55];

// const res = age.map((el) => {
//    return el.toString()

// });

// console.log(res);

//РЕШЕНИЕ № 2          Приведение типов:

// const num = [2, 4, 6, 8, 10];

// const priv = num.map(elem => '' + elem);

// console.log(priv);

//Конкатенация строки с числом
//Конкатенация строк - это операция объединения двух или более строк в одну строку.
// const t = 111;

// const r =  'о ' + t;
// console.log(r);

// const message = 'The answer is: ' + 42;

// console.log(message);

// const firstName = 'John';
// const lastName = 'Doe';

// const fullName = firstName + ' ' + lastName;

// console.log(fullName);

//РЕШЕНИЕ № 3          Шаблонные строки:

// const num = [11.2, 11.3, 11.4, 11.5,];

// const storage = num.map( elem => `${elem}`)

// console.log(storage);

//ещё

// const r = num.map(e => `${e}`)

// console.log(r);

//6 Извлечение уникальных значений из массива объектов: Напишите функцию, которая принимает массив объектов и возвращает новый массив, содержащий уникальные значения определенного свойства (например, "id") из всех объектов.

// const stud = [
//     { Call: "1 Fat", years: 30, id: 123 },
//     { Call: "1 Fat", years: 30, id: 123 },
//     { Call: "2 Long", years: 19, id: 456 },
//     { Call: "3 Jim", years: 29, id: 789 },
//     { Call: "4 Jim1", years: 28, id: 1011 },
//     { Call: "5 Jim2", years: 89, id: 1213 },
//     { Call: "6 Jim3", years: 99, id: 1415 },
// ];

//console.log(stud.map(el => el.id));

// const id = [...new Set(stud.map((e) => e.id))]; //Этот код создает новый массив, в котором используется метод map() для извлечения всех значений свойства "id" из массива объектов students. Затем создается объект Set, который автоматически удаляет дубликаты. Наконец, с помощью оператора расширения массива ... Set преобразуется обратно в массив уникальных значений "id", который сохраняется в переменной uniqueIds.

//квадратные скобки [...] используются для создания нового массива, который содержит уникальные идентификаторы, преобразованные из массива объектов students с использованием объекта Set.

//new Set(...): Оператор new используется для создания нового экземпляра объекта. В данном случае, мы создаем новый объект Set, который является структурой данных для хранения уникальных значений. При создании нового экземпляра Set, вы передаете массив уникальных идентификаторов, полученный с помощью students.map(el => el.id). Объект Set автоматически удаляет дубликаты, поэтому он содержит только уникальные идентификаторы.

//[...]: Это синтаксис расширения массива (spread syntax), который используется для распаковки элементов из объекта Set в новый массив. Объект Set сам по себе не является массивом, поэтому мы используем расширение массива, чтобы преобразовать его содержимое в массив.

// console.log(id);

//6.1. Пример использования оператора - ... - JavaScript используется для распаковки элементов из итерируемого объекта, такого как массив или объект Set, и создания нового массива или передачи элементов в другую функцию как аргументы.

// const arr = [11, 22, 33];

// const arrTwo = [12, 23, 34];

// const unt = [...arr, ...arrTwo];
// console.log(unt);

//6.1.1 Используем ... - этот оператор для передачи элементов в другую функцию как аргументы

// function plus(x, y, z){
//     return x + y + z;
// }

// const num = [30, 20, 40];

// const res = plus(...num) // Это расширение массива передает каждый элемент массива как отдельный аргумент функции sum

// console.log(res); // Вывод: 90

//6.1.2 Используем Set

//слово Set является зарезервированным словом в JavaScript, используемым для создания структуры данных Set. Set - это объект, который содержит уникальные значения и обеспечивает эффективный способ проверки наличия элемента в коллекции. Он может содержать значения любого типа данных, и каждое значение в коллекции Set появляется только один раз.Set является частью встроенных объектов JavaScript и не может быть использовано в качестве идентификатора для переменных или функций.

// const storage =  new Set();

// storage.add(10);
// storage.add(20);
// storage.add(30);
// storage.add(40);
// storage.add(40);

// console.log(storage);

// console.log(storage.has(20));
// console.log(storage.has(70));

// !!!!!!!!!!!!          ДЕСТРУКТУРИЗАЦИЯ      !!!!!!!!!!!!!!

//  destructured assignment

// Деструктуризация в JavaScript - это специальный синтаксис, который позволяет извлекать значения из массивов или объектов и присваивать их переменным более простым способом. Это удобный способ извлечения данных из структур данных и использования их в коде.

//Деструктуризация объекта

// const user = {
//     Call: "Ike",
//     age: 25,
//     unemployed: true,
// };

// const {  age, Call} = user;
// const { unemployed } = user; //извлекаем значения из объекта и присваиваем их переменным

// console.log(Call);
// console.log(age);
// console.log(unemployed);

//Деструктуризация массива

// const vegetables = ['carrot', 'beet', 'tomato', 'cucumber', 'pickl'];

// const [carrot, beet, tomato, cucumber, picklRick] = vegetables; //порядк элементов важен, НАЗВАНИЯ МОЖНО ДАВАТЬ ЛЮБЫЕ

// console.log(carrot);
// console.log(picklRick);

// //Деструтуризация в функциях

// const user2 = {
//     call: 'Nik',
//     age: 25,
//     employed: true,
// }

// const info = ({call, age, employed}) => { //деструктуризация параметров функции
//     if (!employed){
//         return console.log(`User ${call} has no job`);
//     }
//     return console.log(`User ${call} has a job and him ${age}`);
// }

// info(user2)//User Nik has a job and him 25

//деструкторизацию можно использовать и внутри функции

//Практика!!!

// № 1 Задание
// const user = {
//     call: 'Mik',
//     age:20,
//     country: 'Netherlands'
// }

// const {call, age,   country} = user;

// console.log(call, age, country);

//  № 2 Задание

// const colors = ['red', 'green', 'blue'];

// const [red, green, blue] = colors;

// console.log(red, green, blue);

// № 3 Задание. Деструктуризация в параметрах функции:

// person = {
//     name: "James",
//     age: 25,
// }

// function printPerson({name, age}){
//     return console.log( name, age);
// }

// printPerson(person);

//4. Деструктуризация вложенных объектов:

// const stud = {
//     Sname: 'Alick',
//     about: {
//         evaluations: 5,
//         years: 27,
//     }
// }

// // const {Sname, about} = stud;

// // const {evaluations, years} = about;
// // console.log(Sname, about, evaluations, years);

// const {Sname, about: {evaluations, years}} = stud;  //ПРЕДПОЧТИТЕЛЬНЕЕ!
// console.log(Sname,  evaluations, years);

//5.Использование значения по умолчанию:

// const person = {
//     Sname: 'John',
//     age: 30,
// };

// const {Sname, age, country = 'USA' } = person;

// console.log(Sname, age, country);

// Условные инструкции (Тернарный оператор (выражение которое возвращает результат), switch, if, if ... else)

//Инструкция выполняет определённое действие

/*

Парсинг - это процесс анализа и извлечения структурированных данных из текста или другого вида входной информации. Этот процесс может включать в себя различные этапы, такие как синтаксический анализ, сегментация, токенизация, анализ грамматики и т. д., в зависимости от конкретных требований задачи и формата данных.

Например, парсинг HTML-страницы может включать в себя извлечение информации из тегов HTML, а парсинг JSON-файла - извлечение данных из JSON-структуры.

В общем, цель парсинга состоит в том, чтобы преобразовать неструктурированные или слабоструктурированные данные в структурированный формат, который можно обработать и использовать для различных целей, таких как анализ, хранение, визуализация и др.
*/

// {
//     "userId": 1,
//     "id": 1,
//     "title": "Test title",
//     "status":{
//         "completed": false
//     }
// }
// JSON- формат обмена данными между клиентом и API.

//Передача данных происходи в виде строки:

//{"userId": 1,"id": 1,"title": "Test title","status":{"completed": false}}

//JSON (JavaScript Object Notation) является форматом обмена данными, который широко используется для передачи структурированной информации между клиентскими приложениями и серверными API. JSON представляет собой текстовый формат, основанный на JavaScript, и позволяет представлять данные в виде пар ключ-значение, массивов и вложенных структур данных.

// JSON обычно применяется в веб-разработке для обмена данными между клиентом и сервером посредством HTTP-запросов. Например, когда клиентское веб-приложение отправляет запрос на сервер для получения данных или отправляет данные на сервер для обработки, они могут быть представлены в формате JSON. Затем сервер обрабатывает запрос и отправляет ответ также в формате JSON, который затем может быть обработан клиентским приложением.

// JSON прост в использовании, легко читаем и записываем для человека, а также легко обрабатывается компьютером. Это делает его популярным выбором для обмена данными во многих веб-приложениях и API.

// "" - объязытально нужно использовать двойные кавычки в JSON

// как конвертировать JSON:

//От сервера JSON.parse()  //из строки обратно в объект
//От клиента JSON.stringify() //из объекта  обратно в строку


//То что я вводил в консоль:

/*

const data = {
    title: 'Title', words: 5 
}
undefined
data
{title: 'Title', words: 5}title: "Title"words: 5[[Prototype]]: Objectconstructor: ƒ Object()hasOwnProperty: ƒ hasOwnProperty()isPrototypeOf: ƒ isPrototypeOf()propertyIsEnumerable: ƒ propertyIsEnumerable()toLocaleString: ƒ toLocaleString()toString: ƒ toString()valueOf: ƒ valueOf()__defineGetter__: ƒ __defineGetter__()__defineSetter__: ƒ __defineSetter__()__lookupGetter__: ƒ __lookupGetter__()__lookupSetter__: ƒ __lookupSetter__()__proto__: (…)get __proto__: ƒ __proto__()set __proto__: ƒ __proto__()
JSON
JSON {Symbol(Symbol.toStringTag): 'JSON', parse: ƒ, stringify: ƒ, rawJSON: ƒ, isRawJSON: ƒ}isRawJSON: ƒ isRawJSON()parse: ƒ parse()length: 2name: "parse"arguments: (…)caller: [Исключение: TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them
    at Function.invokeGetter (<anonymous>:3:28)][[Prototype]]: ƒ ()[[Scopes]]: Scopes[0]rawJSON: ƒ rawJSON()stringify: ƒ stringify()length: 3name: "stringify"arguments: (…)caller: (…)[[Prototype]]: ƒ ()[[Scopes]]: Scopes[0]Symbol(Symbol.toStringTag): "JSON"[[Prototype]]: Object
JSON.STR
undefined
JSON.stringify(post)
VM255:1 Uncaught ReferenceError: post is not defined
    at <anonymous>:1:16
(анонимная) @ VM255:1
JSON.stringify(data)
'{"title":"Title","words":5}'
JSON
JSON {Symbol(Symbol.toStringTag): 'JSON', parse: ƒ, stringify: ƒ, rawJSON: ƒ, isRawJSON: ƒ}
const pastData = JSON.stringify(data)
undefined
JSON.parse(pastData)
{title: 'Title', words: 5}title: "Title"words: 5[[Prototype]]: Objectconstructor: ƒ Object()hasOwnProperty: ƒ hasOwnProperty()isPrototypeOf: ƒ isPrototypeOf()propertyIsEnumerable: ƒ propertyIsEnumerable()toLocaleString: ƒ toLocaleString()toString: ƒ toString()valueOf: ƒ valueOf()__defineGetter__: ƒ __defineGetter__()__defineSetter__: ƒ __defineSetter__()__lookupGetter__: ƒ __lookupGetter__()__lookupSetter__: ƒ __lookupSetter__()__proto__: (…)get __proto__: ƒ __proto__()set __proto__: ƒ __proto__()

*/






//.then(response => response.json()) // Преобразует тело ответа в объект JavaScript


//задания

//Условные инструкции,  Условная инструкция if else, Использование if в функциях, Инструкция Switch
//Тернарный оператор
//Циклы
//Цикл for
// Для перебора массивов не нужен for
// Цикл while
// Цикл do while
// Цикл for in
// Методы keys и values для объектов
// Цикл for in для массивов
// Цикл for of


//Напишите программу, которая проверяет, является ли число четным или нечетным

// function Even0rOdd(num){
//     if(num % 2 === 0){
//         return "Даноое число - " + num + " - чётное"
//     } else {
//         return "Данное число -" + num + " - НЕ чётное"
//     }
// }


// let num = 17;
// console.log(Even0rOdd(num));
// const a = 10;
// console.log(a % 2);




// const n = 11;

//     ((n) => {
//         if(n %2 === 0){
//             return console.log(n + " число чётное"); 
//         } else{
//             return console.log(n + " число не чётное"); 
//         }
//     })(n)



    /*

((n) => {
    if (n % 2 === 0) {
        console.log(n + " - число чётное");
    } else {
        console.log(n + " - число нечётное");
    }
}) - а зачем писать эту функцию в рамках круглых скобок
ChatGPT
Помещение функции в круглые скобки имеет особое значение в JavaScript. Если вы хотите вызвать стрелочную функцию сразу после ее определения (также известное как "IIFE" - Immediately Invoked Function Expression), вам нужно обернуть определение функции в круглые скобки.

Почему это необходимо? При определении функции JavaScript интерпретатор ожидает, что после определения функции будет следовать тело самой функции. Однако, если вы хотите немедленно вызвать эту функцию, вы должны заключить определение функции в скобки, чтобы интерпретатор понял, что это не только определение функции, но и ее вызов.

Вот пример:

javascript
Copy code
// Объявление и немедленный вызов стрелочной функции
((n) => {
    if (n % 2 === 0) {
        console.log(n + " - число чётное");
    } else {
        console.log(n + " - число нечётное");
    }
})(11); // Передача значения 11 в качестве аргумента для переменной n
Таким образом, ваши круглые скобки не являются частью определения функции, они используются для немедленного вызова этой функции.






    */


// num = 12

// function func (num)  {

//     if(num % 2 === 0){
//         return console.log( `чётное - ${num} - число`);
//     }else{
//         return console.log(`не чётное - ${num} - число`); 
//     }
// }

// func(num)




//самый короткий вариант:
// num = 12

//     if(num % 2 === 0){
//         console.log( `чётное - ${num} `);
//     }else{
//         console.log(`не чётное - ${num} `); 
//     }



//2. Условная инструкция if else: Создайте программу, которая проверяет, является ли число положительным, отрицательным или нулем.

// function Even0rOdd(num){
    
//     if(num != 0 ){ 
//         if(num % 2 === 0){
//         return "Даноое число - " + num + " - чётное"
//         } else {
//         return "Данное число -" + num + " - НЕ чётное"
//         }
//     } else {
//         return console.log("NULL");
//     }
// }


// let num = 1;
// console.log(Even0rOdd(num));






//3. Использование if в функциях: Напишите функцию, которая принимает на вход число и выводит сообщение о том, является ли оно четным или нечетным.




// const read  = require('readline');

// const ObjInterfaceIO = read.createInterface({
//     input: process.stdin,
//     output: process.stdout
// });



//     function func (num) {
//         if(num % 2  === 0) {
//             console.log(num + "- чётное");
//         }else{
//             console.log(num + "- не чётное");
//         }
//     }

// ObjInterfaceIO.question('Введи число: ', (inputedNum) =>{
//         const num = parseInt(inputedNum);

//         if (!isNaN(num)){
//             func(num);
//         }else{
//             console.log('Не правильный ввод.');
//         }
//     ObjInterfaceIO.close(); // Закрываем интерфейс после завершения ввода/вывода
// });



//Пример испотзования остатка
//console.log(к = 11 % 10 );




// 4. Инструкция Switch: Напишите программу, которая на основе введенного дня недели выводит соответствующее сообщение (например, "Понедельник", "Вторник", и т.д.).

// let num = parseInt(prompt("Ведите номер дня недели (от 1 до 7)"))

// switch (num){
//     case 1:
//     console.log("Понедельник");
//     break;

//     case 2:
//     console.log("Вторник");
//     break;
    

//     case 3:
//     console.log("среда ");
//     break;

//     case 4:
//     console.log("четверг");
//     break;
    

//     case 5:
//     console.log("пятница");
//     break;
    

//     case 6:
//     console.log("суббота");
//     break;
    

//     case 7:
//     console.log("воскресенье");   
//     break;

//     default:
//     console.log("Еrror");
// }





// Поскольку prompt() возвращает строку, даже если пользователь вводит число, необходимо использовать parseInt() для преобразования этой строки в число




/*

чем switch case отличается от if else

2 / 2

ChatGPT
switch и case и if и else - это оба конструкции управления потоком в JavaScript, но они имеют различные применения и особенности.

Основные различия между switch и case и if и else:

Условия: if и else проверяют условия на истинность или ложность. switch и case сравнивают выражение со значениями в case.

Гибкость: if и else позволяют проверять различные условия, в то время как switch и case сравнивают только одно выражение с несколькими вариантами значений.

Читаемость: В некоторых сценариях switch и case могут сделать код более читаемым, особенно когда требуется проверить одну переменную на несколько возможных значений. Однако при наличии большого количества условий switch и case могут стать громоздкими и менее читаемыми.

Поведение: В switch и case используется строгая проверка равенства (===). В if и else вы можете использовать различные операторы сравнения, такие как ==, ===, <, >, <=, >=.

Поиск: switch и case могут быть более эффективными в некоторых случаях, особенно когда сравнивается одно и то же значение с несколькими вариантами. Однако это зависит от реализации JavaScript.

В общем, if и else предоставляют большую гибкость, в то время как switch и case могут быть более удобными в определенных ситуациях, особенно когда нужно сравнить одно значение с несколькими вариантами.

*/



//Задача на перевод в строку числа и получения его первого элемента

// const d = 23;

// const numm = d.toString()[0];

// console.log(numm);

// console.log(d.toString()[0]);








//5.Тернарный оператор: Напишите программу, которая проверяет, является ли число положительным или отрицательным, используя тернарный оператор.

// let n = parseInt(prompt("Ввод числа: "));


//уcловный оператор
// if(num > 0 || num < 0){
//     console.log("positeve or/and negative");
//     if(num > 0){
//         console.log("positeve");
//     }else{
//         console.log(" negative");
//     }
// } else{
//     console.log("Not a write input");
// }


// let res = (number > 0) ? "Положительное" 
// : (number < 0) ? "Отрицательное" 
// : "Ноль";

// console.log(res);


// let r = (n > 0) ? "Положительное" : (n < 0) ? "Отрицательное": "null";

// console.log(r);







//6. Циклы:Напишите программу, которая выводит числа от 1 до 10 в консоль.


// for (i = 1; i < 11; i++){
//     console.log(i); 
// }



//7 Цикл for: Используя цикл for, выведите все числа от 1 до 20, которые делятся на 3 без остатка.

// for (i = 1; i < 21; i++){
//     if (i % 3 == 0){
//         console.log(i); 
//     }
    
// }


//2-ое решение

// for(i = 3; i < 21; i +=3){
//     console.log(i);
// }

//8. Для перебора массивов не нужен for: Создайте массив чисел и используйте метод forEach() для вывода каждого элемента массива в консоль.


// const a = [1, 2, 3, 4, 5, 65, 67, 88, 99, 100];

// a.forEach((d) => console.log(d));


//9. Цикл while: Напишите программу, которая выводит все числа от 1 до 10 с использованием цикла while.

// let a = 0;
// while(a < 10){
//     a++
//     console.log(a);
// }


//10)Цикл do while: Создайте программу, которая запрашивает у пользователя число, а затем выводит все числа от этого числа до 0 с использованием цикла do while.

// let answer = parseInt(prompt("Введите число: "));


// let i = answer;

// do{
   
//     console.log(i);
//     i--;
// }while (i >= 0);


// let a = answer;
// do{
//     console.log(a);
//     a--
// }while(a >- 0)



// 11) Цикл for in: Создайте объект с несколькими свойствами и используйте цикл for...in для вывода всех его свойств в консоль.


// SomeObj =  {
//     m: 100,
//     v: 10,
//     weight: 11,
// }

// for(let k in SomeObj){
//     console.log(k + " = " + SomeObj[k]);
// }



//Методы keys и values для объектов: Создайте объект и используйте методы Object.keys() и Object.values() для вывода ключей и значений объекта в консоль.

// SomeObj =  {
//     m: 100,
//     v: 10,
//     weight: 11,
// }


// Object.keys(SomeObj).forEach(key => {
    
//     console.log(key, SomeObj[key])

// });

// Object.values(SomeObj).forEach(value => {
//     console.log(value);
// })




/*

Object.keys(SomeObj).forEach - что тут происходит?

ChatGPT
Вы правильно заметили, что в этой строке используется метод Object.keys(), который принимает объект в качестве аргумента и возвращает массив его собственных перечисляемых свойств (ключей). Затем к полученному массиву применяется метод forEach, который выполняет указанную функцию один раз для каждого элемента в массиве.

Таким образом, выражение Object.keys(SomeObj) создает массив из ключей объекта SomeObj, а forEach используется для перебора этого массива. Каждый ключ передается в функцию обратного вызова (key => {...}), которая выводит ключ и соответствующее значение объекта в консоль.

User
(key => {
    
    console.log(key, SomeObj[key])

}); - почему эта функция называется функцией обратного вызова?
ChatGPT
Функция (key => {...}), переданная в качестве аргумента методу forEach, называется функцией обратного вызова, потому что она вызывается автоматически в определенный момент времени программой или методом, когда выполняются определенные условия.

В данном случае, когда forEach перебирает элементы массива, для каждого элемента вызывается функция обратного вызова. Таким образом, функция обратного вызова "обратно вызывается" методом forEach для каждого элемента массива.

Функции обратного вызова часто используются в JavaScript для выполнения определенных действий после выполнения асинхронных операций, перебора массивов или выполнения других действий, когда программе необходимо выполнить какие-то действия в определенный момент времени.

*/



//13. Цикл for in для массивов: Создайте массив и используйте цикл for...in для вывода индексов массива в консоль.

// const a = [0, 1, 2, 3, 4, 5, 6];

// for(key in a){
//     console.log(key);
// }


//Цикл for of:Создайте массив и используйте цикл for...of для вывода всех его элементов в консоль.

// const a = [0, 1, 2, 3, 4, 5, 6];

// for(key of a){
//     console.log(key);
// }


//FOR OF  - НЕ ДЛЯ ОБЪЕКТОВ!!!


// чем отличается Цикл for of от Цикла for in?
// ChatGPT
// Циклы for...of и for...in в JavaScript предназначены для разных целей и имеют различное поведение:

// Цикл for...of:
// Используется для перебора элементов итерируемых объектов, таких как массивы, строки, Map, Set и другие.
// В каждой итерации в переменную записывается значение элемента, а не его индекс или ключ.
// Не перебирает свойства объекта, которые не являются перечисляемыми.
// Не требует явного указания длины объекта или использования индексов.
// Пример использования for...of для массива:

// javascript
// Copy code
// const arr = [1, 2, 3];
// for (const element of arr) {
//     console.log(element); // Выведет: 1, 2, 3
// }
// Цикл for...in:
// Используется для перебора перечисляемых свойств объекта, включая свойства, унаследованные от прототипа.
// В каждой итерации в переменную записывается имя свойства (ключ), а не его значение.
// Может перебирать не только собственные свойства объекта, но и свойства, унаследованные от прототипа, если они перечисляемые.
// Может не гарантировать порядок перебора свойств, особенно в объектах.
// Пример использования for...in для объекта:

// javascript
// Copy code
// const obj = { a: 1, b: 2, c: 3 };
// for (const key in obj) {
//     console.log(key); // Выведет: a, b, c
//     console.log(obj[key]); // Выведет: 1, 2, 3
// }
// Таким образом, основное отличие между for...of и for...in заключается в том, что первый используется для перебора элементов итерируемых объектов, а второй - для перебора свойств объекта.




// function fm(ar){

//     if(ar.length === 0){
//         return undefined;
//     }

//     let maximal = ar[0];

//     for(let i = 1; i < ar.length; i++){
//         if(ar[i] > maximal){
//             maximal = ar[i];
//         }
        
//     }
//     return maximal;
// }

// let inp = prompt("Число: ")
// let arr = inp.split(",").map(Number);
// let f= fm(arr)

// console.log(f);
 






// function findMax(array){
//     if(array.length === 0){
//         return undefined
//     }

//     let max = array[0];
//     for(let i = 0; i < array.length; i++){
//         if(array[i] > max){
//             max = array[i] 
//         }
//     }
//     return max;
// }


// let input = prompt("Число: ");
// let inputArray = input.split(" ").map(Number);

// let res = findMax(inputArray);

// console.log(res);





//  !!!!!!!!!!!!!!!!!!!!!Модули!!!!!!!!!!!!!!

//Модули позволяют струтурировать код по папкам. А также модульность в js позволяют не повторять одни и те же части кода 

//export ... и import ... - появились в ES6



//часть посвященная :
//07:57:21  Модули
// 08:05:07 Создание и запуск модулей с помощью Node
// 08:18:33 Несколько экспортов
// 08:23:11 Правила работы с модулями
// 08:26:18 Практика по созданию нескольких экспортов
// 08:30:30 Как используются модули в React

//-находится в папке modules



/*
User
а разве компиляция программы не означает её выполнение?

ChatGPT
Компиляция программы и её выполнение - это два различных этапа в жизненном цикле программного кода. Давайте разберем их:

Компиляция программы:

Компиляция - это процесс преобразования исходного кода программы из одного языка программирования в другой. Обычно это происходит с высокоуровневых языков программирования в машинный код, который может быть понятен и исполнен процессором компьютера.
Компиляция обычно происходит до выполнения программы и может включать в себя различные этапы, такие как анализ, оптимизация и генерация исполняемого кода.
Результатом успешной компиляции является исполняемый файл или другая форма скомпилированного кода, который может быть запущен и выполнен на компьютере или другом устройстве.
Выполнение программы:

Выполнение - это процесс фактического запуска программы и выполнения её инструкций компьютером в соответствии с заданным алгоритмом.
После успешной компиляции программы, её исполняемый код может быть запущен на целевой платформе для выполнения.
Во время выполнения программы происходит загрузка данных, обработка операций, взаимодействие с внешними ресурсами (например, файлами, сетью) и вывод результатов.
Таким образом, компиляция и выполнение программы - это два различных этапа. Компиляция преобразует исходный код в исполняемый формат, в то время как выполнение означает реальное выполнение программы на компьютере или устройстве.
*/






























//  !!!!!!!!!!!!!!!!!!!!!!!   КЛАССЫ    !!!!!!!!!!!!!!!!!!!!!!!!!!!!



//классы позволяют создавать прототипы для объектов
//на основании прототипов создаются экземпляры
//экземпляры могут иметь свои свойства и методы
//экзнимпляры наследуют свойства и методы прототипов





//создавать классы в js можно и  без команды class

//Классы: Введены в ECMAScript 2015 (ES6) и представляют собой синтаксический сахар для работы с прототипами и создания объектно-ориентированной иерархии. Они используют ключевое слово class для определения класса, а методы определяются внутри тела класса.



//В JavaScript "пропсы" (props) в объектах обычно означают свойства объекта. 

/*
Объекты в JavaScript представляют собой сборники пар "ключ-значение", где каждый ключ является именем свойства, а значение - соответствующим значением этого свойства. Пример объекта с "пропсами":

javascript
Copy code
const person = {
  name: 'John',
  age: 30,
  gender: 'male'
};

console.log(person.name); // Выведет: John
console.log(person.age); // Выведет: 30
console.log(person.gender); // Выведет: male
В этом примере name, age, и gender - это "пропсы" объекта person. Они используются для хранения и доступа к информации о человеке (в данном случае).
*/



/*

получается что все свойства классов  ( как элементов в js) могут быть присчущи и объектам js?

2 / 2

ChatGPT
Да, в JavaScript все свойства и методы, которые могут быть определены в классах (функциях-конструкторах или объектах), также могут быть присущи обычным объектам JavaScript. Это связано с тем, что в JavaScript всё является объектами, включая функции, массивы и даже классы, созданные с помощью ключевого слова class.

Вот некоторые основные типы свойств и методов, которые могут присутствовать как в классах, так и в обычных объектах:

Свойства:

Простые значения (числа, строки, логические значения и т. д.)
Объекты
Функции
Массивы
Другие объекты
Методы:

Функции
Методы, определенные через свойство объекта
Методы, определенные в прототипе объекта
Поскольку в JavaScript объекты могут содержать любые типы данных и ссылаться на другие объекты, вы можете определять любые свойства и методы в объектах, так же как и в классах. Таким образом, объекты в JavaScript обладают большой гибкостью и могут быть использованы для реализации различных паттернов проектирования и структур данных.

*/





/*
а может ли обычный объект создавать прототипы для других объектов?
ChatGPT
Да, в JavaScript любой объект может быть использован в качестве прототипа для других объектов. Прототипное наследование в JavaScript позволяет объектам наследовать свойства и методы других объектов, что делает его мощным инструментом для организации кода и повторного использования.

// Вот пример создания прототипа с использованием обычного объекта:
// */

// // let PapaObj = {
// //     papaProps: "SomePaValue",
// //     papaMethod: function(){
// //         console.log(this.papaProps);
// //     }
// // };

// // let sonObject = Object.create(PapaObj); //Теперь объект sonObject имеет доступ к свойствам и методам объекта PapaObj, так как он был создан с использованием Object.create(PapaObj).

// // sonObject.sonProp = 'valueSon';
// // sonObject.sonMethod = function(){
// //     console.log(this.sonProp);
// // } 


// // sonObject.papaMethod();
// // sonObject.sonMethod();


// //В этом примере sonObject создан с использованием Object.create(PapaObj), что делает PapaObj прототипом для sonObject. Таким образом, sonObject наследует свойства и методы от PapaObj, но также имеет свои собственные уникальные свойства и методы.


//Object.create() - это стандартный метод в JavaScript, который создает новый объект с указанным прототипом и свойствами. Этот метод принимает один аргумент - объект, который станет прототипом для создаваемого объекта.




/*


let PapaObj = {
    papaProps: "SomePaValue",
    papaMethod: fun(){
        console.log(papaProps);
    }
}; - почему нельзя писать методы таким образом?

ChatGPT
Ваш код имеет несколько синтаксических ошибок:

Вам следует использовать ключевое слово function для объявления функции, а не fun().
Вы забыли указать, что papaProps должен быть взят из PapaObj. Для обращения к свойству объекта из его метода используйте ключевое слово this.
Исправленный вариант выглядит следующим образом:

javascript
Copy code
let PapaObj = {
    papaProps: "SomePaValue",
    papaMethod: function() {
        console.log(this.papaProps);
    }
};
Теперь метод papaMethod должен правильно работать, обращаясь к свойству papaProps объекта PapaObj.

User
а почему нужно писать function ? можно ли писть через стрелочные функции ?
ChatGPT
В JavaScript существуют два способа определения функций: через ключевое слово function и через стрелочные функции (=>).

Стрелочные функции имеют некоторые различия по сравнению с обычными функциями, в том числе:

Они не имеют собственного this. Вместо этого они заимствуют this из окружающего контекста. Это означает, что внутри стрелочной функции нельзя использовать this, чтобы обратиться к контексту объекта, в котором она была вызвана.

Они не имеют своего собственного arguments.

В контексте вашего вопроса описанные выше особенности стрелочных функций могут вызвать проблемы при использовании их в методах объекта, так как this в стрелочной функции будет ссылаться на внешний контекст, а не на объект, в котором она была определена. В результате метод не сможет получить доступ к свойствам объекта через this.

Вот пример, как использование стрелочной функции может вызвать проблемы в вашем коде:

javascript
Copy code
let PapaObj = {
    papaProps: "SomePaValue",
    // Используем стрелочную функцию
    papaMethod: () => {
        console.log(this.papaProps); // this здесь будет ссылаться на глобальный контекст, а не на PapaObj
    }
};

PapaObj.papaMethod(); // Выведет undefined
Поэтому в случае определения методов объекта, особенно если они будут использовать this, лучше использовать обычные функции, объявленные с помощью ключевого слова function

*/















//Возвращаемся к классам
//КЛАСС - это Надстройка над JS

//Array и Object - это тоже классы. В JavaScript как Array, так и Object являются встроенными классами (или конструкторами) языка. Они используются для создания массивов и объектов соответственно.


//PascalCase  используется в названии классов

//  this - В конструкторе: Внутри конструктора this ссылается на создаваемый объект, то есть на экземпляр класса, который будет создан при вызове конструктора с помощью оператора new.

// //this указывает на экземпляр класса
// //Пример класса:

// class Comment {
//     constructor(SomeText){ //метод
//         this.SomeText = SomeText //присваивание
//         this.words = 8  //присваивание
//     } //конструктор вызывается только тогда когда вы создаёте новый экземпляр конкретного объекта

//     upvote(){
//         this.words += 1 //вы можете обращаться к свойствам и методам конкретного экземпляра и изменять их значения // upvote - данный метод находится на уровне класса он не будет присвоен как отдельный метод конкретного экземпляра этого коментария но он будет наследоваться всеми экземплярами этого класса коментария (точно также как и forEach или map)
//     }
    
// } // - такой класс (Comment) является всего лищь шаблоном для создания новых объектов и когда мы будем создавать новый экземпляр такого класса, то this будет автоматически ссылаться на такой вот новый экземпляр и ссылаясь на конкретный экземпляр класса вы можете соответсвенно внутри класса, внутри методов класса и свойств класса менять собственные свойства и методы конкретного экземпляра.

/*

Этот комментарий, который вы привели, объясняет использование ключевого слова this в контексте объектно-ориентированного программирования на языке JavaScript. Давайте разберём по частям:

"this указывает на экземпляр класса": this в JavaScript используется для ссылки на текущий объект, к которому применяется контекст. В данном случае, когда вы создаёте экземпляр класса Comment, this будет ссылаться на этот экземпляр.

"то есть такой класс является всего лишь шаблоном для создания новых объектов": Это верно. Класс Comment является шаблоном, описывающим структуру и поведение объектов, которые будут создаваться на его основе.

"когда мы будем создавать новый экземпляр такого класса, то this будет автоматически ссылаться на такой вот новый экземпляр": Когда вы создаёте новый объект на основе класса Comment, например, let comment = new Comment('some text');, внутри конструктора и методов this будет ссылаться на этот конкретный экземпляр comment.

"ссылаясь на конкретный экземпляр класса вы можете соответственно внутри класса, внутри методов класса и свойств класса менять собственные свойства и методы конкретного экземпляра": Правильно. Используя this в методах класса, вы можете обращаться к свойствам и методам конкретного экземпляра и изменять их значения. Например, в методе upvote() класса Comment, this.words += 1; увеличивает количество слов в конкретном комментарии на 1.




User
"когда мы будем создавать новый экземпляр такого класса, то this будет автоматически ссылаться на такой вот новый экземпляр"  - объясни это выражение по подробнее и по понятнее
ChatGPT
Конечно, давайте разберём это более подробно.

Когда вы создаёте новый объект на основе класса в JavaScript, это создаёт экземпляр этого класса. Другими словами, это конкретный объект, который содержит все свойства и методы, определённые в этом классе.

Когда вы внутри этого класса обращаетесь к ключевому слову this, оно ссылается именно на этот экземпляр класса, на тот объект, который вы создали с помощью этого класса.

Таким образом, если вы используете this внутри метода класса, этот this будет автоматически указывать на текущий экземпляр класса, к которому применяется этот метод.

Например, если у вас есть класс Comment, и вы создаёте новый комментарий с помощью этого класса, когда вы обращаетесь к this внутри метода этого класса, он будет автоматически ссылаться на созданный вами конкретный комментарий. Таким образом, вы можете легко изменять свойства этого конкретного комментария с помощью this.
*/






//экземпляры классов в js создаются с помощью вызова функций!!!

//ЧТО ОЗНАЧАЕТ ВЫРАЖЕНИЕ  - ЧТО "экземпляры классов в js создаются с помощью вызова функций"?

// Высказывание "экземпляры классов в JavaScript создаются с помощью вызова функций" может быть немного запутанным, но имеет смысл, когда говорим о создании объектов на основе классов в JavaScript.

// В JavaScript классы, определенные с использованием ключевого слова class, фактически являются функциями-конструкторами. При создании экземпляра класса с использованием оператора new, вызывается функция-конструктор класса для создания нового объекта.

//Пример:


// class Man {
//     constructor(call){
//         this.call = call;
//     }
// }


// let Alex = new Man("Johny");

// console.log(Alex instanceof Man);
//Оператор instanceof в JavaScript используется для проверки, принадлежит ли объект к определенному классу или наследует ли его от определенного класса.

// Здесь Person - это функция-конструктор, определенная с использованием ключевого слова class. При использовании оператора new эта функция вызывается, чтобы создать новый объект john, который является экземпляром класса Person.

// Таким образом, в контексте JavaScript можно сказать, что экземпляры классов создаются с помощью вызова функций, имея в виду, что классы на самом деле являются функциями-конструкторами, которые вызываются при создании объектов с использованием оператора new.



/*
что такое экземпляр класса?
ChatGPT
Экземпляр класса - это конкретный объект, который был создан с использованием определения класса. Когда вы создаете экземпляр класса, вы создаете конкретный объект, который имеет свойства и методы, определенные в этом классе.

Другими словами, экземпляр класса представляет собой конкретное воплощение (инстанцию) класса. Класс сам по себе является шаблоном или описанием, а экземпляры класса - это конкретные объекты, которые соответствуют этому описанию.

Пример:

javascript
Copy code
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  greet() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
  }
}

// Создание экземпляра класса Person
let john = new Person("John", 30);

// Создание еще одного экземпляра класса Person
let mary = new Person("Mary", 25);

john.greet(); // Выведет: Hello, my name is John and I am 30 years old.
mary.greet(); // Выведет: Hello, my name is Mary and I am 25 years old.
Здесь john и mary - это экземпляры класса Person, каждый из которых является отдельным объектом со своими собственными значениями свойств name и age.

User
 greet() - что это ? Спец функция?
ChatGPT
Функция greet() в приведенном примере является методом класса Person. В контексте классов в JavaScript, метод - это функция, определенная внутри тела класса. Он представляет собой действие или операцию, которую можно выполнить с экземпляром класса.

В данном примере метод greet() отвечает за приветствие объекта класса Person, выводя его имя и возраст в консоль.

Методы класса работают так же, как обычные функции, но они связаны с объектами класса и могут получать доступ к их свойствам через ключевое слово this.

Пример использования метода:

javascript
Copy code
let john = new Person("John", 30);
john.greet(); // Вызов метода greet() для объекта john
Этот вызов метода greet() приведет к выводу приветствия в консоль, используя имя и возраст объекта john.

User
как соотносятся между собой понятие экземпляр и прототип?
ChatGPT
Понятие экземпляра и прототипа тесно связаны в JavaScript, поскольку прототип используется для реализации наследования и доступа к свойствам и методам объекта.

Экземпляр (инстанс): Экземпляр класса - это конкретный объект, созданный на основе определения класса. Каждый экземпляр имеет свои собственные значения свойств и методов, определенных в классе.

Прототип: Прототип - это объект, который является общим для всех экземпляров класса и содержит свойства и методы, которые могут быть унаследованы всеми экземплярами этого класса. Каждый объект в JavaScript имеет ссылку на свой прототип, через который он может наследовать свойства и методы.

Соотношение между экземпляром и прототипом заключается в том, что каждый экземпляр класса имеет свой прототип. Когда вы обращаетесь к свойству или методу объекта, JavaScript сначала ищет его в самом объекте. Если свойство или метод не найдены непосредственно в объекте, JavaScript будет искать их в прототипе этого объекта. Если они не найдены и в прототипе, поиск будет продолжен в прототипе прототипа и так далее, пока не будет найдено соответствующее свойство или метод или пока не будет достигнут конечный прототип null.

Это механизм, который обеспечивает наследование в JavaScript и позволяет объектам иметь доступ к общим свойствам и методам, определенным в прототипе своего класса.
*/


//СОЗДАНИЕ ЭКЗЕМПЛЯРА КЛАССА:
//с помощью ключевого слова new которое используется для создания новых экземпляров объектов с использованием конструктора. Например, new Object() создаст новый объект, а new Date() создаст новый объект типа Date.

//здесь создаётся экземпляр firstText класса - Comment
// const firstText = new Comment("First comment"); //в new Comment - происходит вызов функции constructor, который создаёт новый экземпляр объекта  класса Comment

// console.log(firstText); 


// /*
// Comment {SomeText: 'First comment', words: 8}
// SomeText : "First comment"
// words :  8
// 🔽 [[Prototype]]:  Object
//     ▶️ constructor : class Comment
//     ▶️ upvote : ƒ upvote()
//     ▶️ [[Prototype]] : Object
// */

// //Классы наследуют по умолчанию также методы объектов


// //цепочка прототипов :
// //firstComment => Comment => Object

// console.log( firstText instanceof Comment); //true
// console.log(firstText instanceof Object);  // true


// //вызов унаследованных методов:

// firstText.upvote()
// console.log(firstText.words); //9

// firstText.upvote()
// console.log(firstText.words); //10


//здесь мы вызываем метод upvote() - как метод объекта firstText


/*

что делает метод object.assign?
ChatGPT
Метод Object.assign() в JavaScript используется для копирования значений всех перечисляемых свойств из одного или нескольких исходных объектов в целевой объект. Возвращает целевой объект после присваивания свойств. Если несколько объектов содержат одинаковые ключи, то значения из последних объектов перезапишут значения из предыдущих объектов. Вот пример его использования:

javascript
Copy code
const target = { a: 1, b: 2 };
const source = { b: 4, c: 5 };

Object.assign(target, source);

console.log(target); // { a: 1, b: 4, c: 5 }
Здесь target изменяется так, чтобы содержать все свойства из source. Если свойство уже существует в target, оно будет перезаписано значением из source.


*/



//Практика по созданию классов и экземпляров

//Вод в консоль


// class Text { 
//     constructor(word) {  //прототипы
//             this.SomeWord = word   
//             this.wordsQuolity = 0 
//         }
    
//     upvote() {  //прототипы
//         this.wordsQuolity += 1
//     }
// }



// Text.prototype.constructor  === Text
    
// true // --Это происходит потому, что свойство constructor прототипа Text указывает на сам класс Text.

//





// firstText
// Text {SomeWord: 'First text', wordsQuolity: 0}
// SomeWord :  "First text"
// wordsQuolity :  0 
// [[Prototype]]
// : 
// Object






/*


const firstText = new Text('First text')
undefined
firstText
Text {SomeWord: 'First text', wordsQuolity: 0}SomeWord: "First text"wordsQuolity: 0[[Prototype]]: Objectconstructor: class Textupvote: ƒ upvote()[[Prototype]]: Objectconstructor: ƒ Object()hasOwnProperty: ƒ hasOwnProperty()isPrototypeOf: ƒ isPrototypeOf()propertyIsEnumerable: ƒ propertyIsEnumerable()toLocaleString: ƒ toLocaleString()toString: ƒ toString()valueOf: ƒ valueOf()__defineGetter__: ƒ __defineGetter__()__defineSetter__: ƒ __defineSetter__()__lookupGetter__: ƒ __lookupGetter__()__lookupSetter__: ƒ __lookupSetter__()__proto__: (…)get __proto__: ƒ __proto__()set __proto__: ƒ __proto__()
firstText.upvote
ƒ upvote() {  //прототипы
        this.wordsQuolity += 1
    }
firstText.SomeWord
'First text'
firstText.wordsQuolity
0
firstText.upvote()
undefined
firstText
Text {SomeWord: 'First text', wordsQuolity: 1}SomeWord: "First text"wordsQuolity: 1[[Prototype]]: Object
firstText.upvote()
undefined
firstText.wordsQuolity
2
firstText.hasOwnProperty('SomeWord')
true
firstText.hasOwnProperty('upvote')
false
firstText.hasOwnProperty('hasOwnProperty')
false

*/



// const firstText = new Text('First text')
// const SecondText = new Text("Second text")
// const ThirdText = new Text("Thrid text")







// Статические методы:

// class Text { 
//     constructor(word) {  //прототипы
//             this.SomeWord = word   
//             this.wordsQuolity = 0 
//         }
    
//     upvote() {  //прототипы
//         this.wordsQuolity += 1
//     }

//     static mergeWords(One, Two){ //статический метод
//         return `${One} ${Two}`
//     }
// }
 

//static mergeWords(One, Two) -  метод доступен как свойство класса и не наследуется экземплярами класса !!!, создаются на уровне методов класса 

//static  - ключевое слово 

//Конструктор вызывается автоматически при создании нового экземпляра класса с помощью оператора new. Обычные методы вызываются явно через экземпляр класса. !!!!!! (это относится и к статическим методам)

// Text.mergeWords('One word.', 'Two word.');               

//Text.mergeWords('Some text', 'Some One Text') - в консоле данный метод вызывается через название класса (тоесть как метод объекта Text не как метод экземпляра объекта - в этом и есть отличие статических методов и унаследованных методов) !!!!

// метод upvote() - наследуется другим экземплярам а статический метод не наследуется !!!!






// Расширение других классов - т.е. мы расширяем класс Array и хотим добавить ещё один метод, который будет доступен всем массивам (экземплярам), которые создаются используя класс NumArr. 

//Здесь клас NumArr расширяет класс Array 
//Задача данного примера: для любого массива, для любого массива, который создаётся добавлять также метод sum, который (родительский конструктор  Array - вызовется автоматически ) автоматически будет суммировать все элементы массива



//constructor не нужен. (родительский конструктор  Array - вызовется автоматически )


//когда создаётся экземпляр класса myArr, то сначала вызывается конструктор родительского класса Array, который возвращает новый объект (новый массив и это будет массив, которому будут доступны все методы такие как forEach, map, reduce и т.д. ) и благодаря этому у нас будет создан объект, который будет выглядить как массив. Он будет сначала наследовать методы NumArr - а он в свою очередь все методы Array - а он в свою очередь будет наследовать все методы объекта





/*

NumArr(3) [2, 5, 7]
0 : 2
1 : 5
2 : 7
length :  3
🔽[[Prototype]] : Array
    ▶️constructor : class NumArr
    ▶️sum : sum() { return this.reduce((ac, elem) => {…}
    ▶️[[Prototype]] : Array(0)


*/




/*
myArr.sum() //вызываем метод sum()  в консоле для того что бы суммировать числа
14
*/


//    Цепочка прототипов:

// myArray => NumbersArray  => Array  => Object

// class NumArr extends Array { 

//     sum() {
//         return this.reduce((ac, elem) => ac + elem, 0)
//     }
// }

// const myArr = new NumArr(2, 5, 7)

// console.log(myArr);

// myArr.sum() //суммирование с помощью reduce()

// //конструктор не нужен

// console.log(myArr.sum());


//extends - дополнение

//Можно сказать что мы расширяем массив Array и хотим добавить ещё один метод всем массивам


//return this.reduce((ac, elem) => ac + elem, 0)

// Синтаксис на этой строке определяет определение класса NumArr, который расширяет встроенный класс Array. Вот разбор синтаксиса:

// class NumArr extends Array: Это объявление класса NumArr, который расширяет встроенный класс Array. Это означает, что класс NumArr наследует все свойства и методы класса Array, такие как push(), pop(), reduce() и т. д. Это позволяет нам создавать массивы, которые также будут иметь доступ к методам, определенным в классе NumArr.

// В методе sum(): reduce((ac, elem) => ac + elem, 0): Этот метод использует метод reduce() для вычисления суммы элементов массива. Метод reduce() принимает функцию обратного вызова и начальное значение. В данном случае, функция обратного вызова принимает два аргумента ac (аккумулятор) и elem (текущий элемент массива) и возвращает их сумму. Начальное значение установлено в 0, что означает, что сумма будет начинаться с нуля.









// !!!!!!!!!!!!!!       Что такое прототип в js?


//У каждого экземпляра того или иного класса есть скрытое свойство -   __proto__     - именно благодаря этому свойству создаётся цепочка прототипов!!!



//если какой-то метод не найден в каком-то объекте то мы смотрим и ищем на уровне родительского прототипа если и там не найден ищем дальше и так по всей цепочке прототипов!!!



//строки и числа - ведут себя как объекты


/*


const num = 10
undefined
num.toString()
'10'


*/



/*
что такое прототип в классах (объясни простыми словами , приведи аналогию ) и как прототип соотносится с классом и с экземпляром класса?
ChatGPT
Прототип в классах JavaScript - это специальный объект, который содержит общие свойства и методы, доступные для всех экземпляров класса. Можно представить прототип как некий шаблон или чертеж, по которому создаются экземпляры класса.

Давайте представим, что класс - это фабрика для производства машин. Прототип будет представлять собой стандартные детали и инструкции по сборке машин, которые используются на этой фабрике. Каждая машина, созданная на этой фабрике, будет иметь те же стандартные детали и будет собрана в соответствии с инструкциями из прототипа.

Соотношение прототипа с классом и экземпляром класса можно проиллюстрировать следующим образом:

Прототип и класс: Прототип связан с классом как своеобразный "заготовленный бланк". Когда вы создаете новый класс, JavaScript автоматически создает для него прототип, который содержит общие свойства и методы, определенные в классе.

Прототип и экземпляр класса: Каждый экземпляр класса имеет доступ к своему прототипу. Это означает, что экземпляр может использовать все свойства и методы, определенные в прототипе своего класса. Если у экземпляра нет своего собственного свойства или метода, JavaScript будет искать их в прототипе и использует их оттуда.

Надеюсь, это поможет вам лучше понять концепцию прототипа в классах JavaScript.

User
constructor - это прототип?
ChatGPT
Нет, constructor не является прототипом. В классах JavaScript, constructor - это специальный метод, который используется для создания и инициализации новых экземпляров класса при вызове оператора new.

Прототип - это объект, который содержит общие свойства и методы, доступные для всех экземпляров класса. Этот объект связан с классом и используется для наследования свойств и методов экземплярами этого класса.

Когда вы создаете новый класс, JavaScript автоматически создает для него прототип, который содержит общие свойства и методы, определенные в классе. constructor - это один из таких методов, который определяет, как создавать новые экземпляры класса.

Таким образом, constructor - это часть класса, которая помогает создавать новые экземпляры, в то время как прототип - это объект, который содержит общие свойства и методы, доступные для всех экземпляров этого класса.
*/








///   !!!Преобразование строки в число 

//1-ый способ  //С помощью оператора + (унарный плюс)

// let df = '21';
// let n = +df;
// console.log(n);



/*

Унарный плюс + в JavaScript имеет два основных применения:

Как оператор сложения: Если перед оператором + стоят числа или строки, то он выполняет сложение. Например, 2 + 2 вернет 4, а '2' + '2' вернет '22'.

Как унарный оператор преобразования в число: Если перед оператором + стоит только один операнд, то он преобразует операнд в число, если это возможно. Если операнд уже является числом, то результат останется числом. Если операнд - строка, содержащая числовое значение, то строка преобразуется в число. Если же строка не содержит числовое значение, результатом будет NaN (Not a Number).

В вашем случае, переменная str содержит строку "42", которая представляет собой числовое значение. Поэтому унарный плюс +str преобразует эту строку в число 42.

Таким образом, вы получаете console.log(num); выводит 42.


User
а почему это происходит? Откуда "растут корни этого явления?
ChatGPT
Исторически, в JavaScript унарный плюс + был предназначен для преобразования строк в числа. Это было сделано для обеспечения удобства и консистентности при работе с данными.

Одним из основных сценариев использования JavaScript является работа с веб-страницами и формами. Когда пользователь вводит данные в форму на веб-странице, значения этих данных обычно передаются как строки. Например, значение из поля ввода текста всегда будет строкой. Поэтому было важно иметь способ легко преобразовывать эти строки в числа для выполнения математических операций.

Унарный плюс + является одним из удобных способов преобразования строк в числа, поскольку он короткий и легко читаемый. Он также консистентен с другими языками программирования, такими как PHP и Python, где унарный плюс также используется для преобразования строк в числа.

Таким образом, преобразование строк в числа с помощью унарного плюса + стало распространенной и широко применяемой практикой в JavaScript.

User
что означает выражение - "консистентности при работе с данными."
ChatGPT
"Консистентность при работе с данными" означает соблюдение единых правил и стандартов при обработке и представлении данных. Это означает, что данные должны быть представлены и обрабатываться в одинаковом формате и структуре, чтобы обеспечить их понимание и согласованность в различных частях системы или программы.

В контексте JavaScript и преобразования строк в числа с помощью унарного плюса +, консистентность означает, что различные операции, связанные с данными, должны вести себя предсказуемо и одинаково в различных ситуациях. Например, когда строка представляет числовое значение, она должна преобразовываться в число, чтобы обеспечить правильное выполнение математических операций. Это помогает программистам и разработчикам создавать более надежные и понятные программы, которые легче поддерживать и развивать.






*/



//2-ой способ: С помощью функции parseInt():

// let a = "100";
// let d = parseInt(a);
// console.log(d);

// // 3-ий: С помощью функции parseFloat()
// let a1 = "100.123";
// let d1 = parseFloat(a1);
// console.log(d1);



// //Повтор: С помощью оператора + (унарный плюс)


// let a2 = "100.123";

// let d2 = +a2;

// console.log(d2);


// //4. С помощью конструктора Number():



// let a3 = "100.123";

// let d3 = Number(a3);

// console.log(d3);




//Практика с reduce():

//Сумма элементов массива: Создайте массив чисел и используйте метод reduce(), чтобы вычислить и вывести сумму всех элементов.

// let a = [1, 2, 3, 4, 5];

// let summa = a.reduce((accum, curentNum) => accum + curentNum, 0);

// //про ноль
// //В функции reduce() второй параметр - это начальное значение аккумулятора. В данном случае, передается 0 как начальное значение для переменной accumulator. Это означает, что сумма будет начинаться с 0 и к ней будут последовательно добавляться значения массива numbers. Если бы не было этого второго параметра, reduce() начал бы суммировать с первого элемента массива numbers.

// console.log(summa);




//Задача из собеседования:

// const obj = [
//     { name: "Sirt", cost: 21},
//     {name: "Jeans", cost: 21},
//     {name: " Cap", cost: 21}
// ]

// let d = obj.reduce((acumulator, countPrice) => acumulator + countPrice.cost, 0);


// console.log(d);



// //ещё раз

// const magazine = [
//     { name: "Sirt", dollars: 21},
//     {name: "Jeans", dollars: 21},
//     {name: " Cap", dollars: 21}
// ]


// let d = magazine.reduce((accum, count) =>  accum + count.dollars,3);


// console.log(d);




//Вот несколько заданий для закрепления методов массивов и изучения метода reduce():

//1. Сумма элементов массива: Создайте массив чисел и используйте метод reduce(), чтобы вычислить и вывести сумму всех элементов.

// let a = [1, 2, 3, 4, 5];

// let r = a.reduce((acum, current) => acum + current, 0);

// console.log(r);



//2. Нахождение среднего значения: Создайте массив чисел и используйте метод reduce(), чтобы найти и вывести среднее значение всех элементов.

//  let a = [10, 20 , 30 , 40, 50];

//  let r = a.reduce((acum, current) => acum + current, 0) / a.length;

//  console.log(r);



//3. Подсчет количества определенных элементов: Создайте массив с различными элементами, включая повторяющиеся, и используйте метод reduce(), чтобы подсчитать количество определенных элементов.


// let arr = [1, 1, 2, 2, 4, 5];

// let quantityUE = arr.reduce((acum, currentElem) => {

//     if(currentElem in acum){ // происходит проверка наличия текущего элемента массива (currentElem) в объекте аккумулятора (acum).

//         acum[currentElem]++; //Каждый элемент массива служит ключом в объекте acum, а его значение - количество раз, которое этот элемент встречается в массиве. Путем увеличения значения свойства acum[currentElem] на 1 при каждом обнаружении элемента currentElem мы фактически подсчитываем, сколько раз этот элемент встречается в массиве. //То есть здесь происходит фиксация того сколько раз встречался тот или иной элемент 

//     }else{
//         acum[currentElem] = 1; // В этой строке кода устанавливается начальное значение для свойства объекта acum, если текущий элемент массива встречается впервые.
//     }
//     return acum;


// }, {});//Этот пустой объект используется в качестве начального значения аккумулятора, который мы будем заполнять ключами и значениями в процессе выполнения метода reduce().


// console.log(quantityUE);


// let ar = [1, 2, 3, 4, 5,  54, 3, 4, 4, 5, 8, 9 ];

// let res = ar.reduce((acummulator, countValue) => {
//     if(countValue in  acummulator){
//         acummulator[countValue]++
//     }else {
//         acummulator[countValue] = 1
//     }

//     return acummulator


// }, {});

// console.log(res);









// let ar1 = [1, 2, 3, 4, 5,  54, 3, 4, 4, 5, 8, 9 ];


// let r = ar1.reduce((ac, curEl) => {

//     if(curEl in ac){
//         ac[curEl]++
//     }else{
//         ac[curEl] = 1
//     }

//     return ac;


// }, {});



// console.log(r);







//4. Объединение значений в строку: Создайте массив строк и используйте метод reduce(), чтобы объединить все строки в одну строку, разделенную запятыми.

// let ar1 = ["12345",  "54344", "589" ];

// let  res = ar1.reduce((acum, currenEl) => {
  
//         return acum + "," + currenEl;
   


// });


// console.log(res);


//второе решение:


// let ar1 = ["12345",  "54344", "589" ];

// let  res = ar1.reduce((acum, currentEl, currentIndex) => {
//     if (currentIndex === 0) {
//         return currentEl; // Если это первый элемент, вернуть его как начальное значение аккумулятора
//     } else {
//         return acum + "," + currentEl; // Иначе объединить текущий элемент с предыдущими значениями
//     }
// }, '');

// console.log(res);





















/*
if (currentValue in accumulator) {
        accumulator[currentValue]++;
    } else {
        accumulator[currentValue] = 1;
    } - что происходит в данной конструкции объясни пошагово

ChatGPT
Конечно, давайте разберем эту конструкцию пошагово:

if (currentValue in accumulator): Это условие проверяет, есть ли текущее значение currentValue в объекте accumulator в качестве ключа.

Если текущее значение уже есть в объекте accumulator как ключ, это означает, что оно уже встречалось ранее в массиве. В этом случае выполняется следующий блок кода:

javascript
Copy code
accumulator[currentValue]++;
Это увеличивает значение по ключу currentValue в объекте accumulator на 1, что означает, что мы обнаружили еще одно вхождение currentValue.

Если текущее значение не было найдено в объекте accumulator как ключ, это означает, что это первое вхождение этого значения в массив. В этом случае выполняется блок кода в блоке else:

javascript
Copy code
accumulator[currentValue] = 1;
Это устанавливает значение ключа currentValue в объекте accumulator равным 1, так как это первое вхождение этого значения в массив.

Таким образом, в результате работы этой конструкции мы строим объект accumulator, который содержит ключи, соответствующие уникальным значениям в массиве, и значения, представляющие количество их вхождений в массиве.
*/



//Поиск максимального и минимального значения:Создайте массив чисел и используйте метод reduce(), чтобы найти и вывести максимальное и минимальное значения.

let ar = [1, 2, 3, 4, 5,  54, 3, 4, 4, 5, 8, 9 ];


let res = ar.reduce(() => {
    
    let min1 = Math.min(...ar);
    return min1
   
})


let res2 = ar.reduce(() => {

    let max1 = Math.max(...ar);


    return  max1
   
})

console.log(res, res2);


//решение № 2

let ar2 = [1, 2, 3, 4, 5,  54, 3, 4, 4, 5, 8, 9 ];


let res22 = ar2.reduce((min, max) => {
    
    let min1 = Math.min(...ar);
    let max1 = Math.max(...ar);


    return min1 + " " + max1
   
},'')

console.log(res22);




//решение № 3














let ar44 = [1, 2, 3, 4, 5,  54, 3, 4, 4, 5, 8, 9 ];


let res44 = ar44.reduce((acum, currentEl) => {
    
    let min =acum[0];
    let max = acum[1];
    
        if ( currentEl < min)
        min = currentEl;
       
        if (currentEl > max)
        max = currentEl;
  
    return [min, max]
   
}, [ar[0], ar[0]]);

console.log(res44);

